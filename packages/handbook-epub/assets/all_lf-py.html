<html><head><style type='text/css'>@font-face {
  font-family: "Cascadia Mono-SemiLight";
  src: url("/fonts/CascadiaMono-SemiLight.woff2") format("woff2");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "Cascadia Code-SemiLight";
  src: url("/fonts/CascadiaCode-SemiLight.woff2") format("woff2");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "JetBrains Mono-Regular";
  src: url("/fonts/JetBrainsMono-Regular.woff2") format("woff2");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "FiraCode-Regular";
  src: url("/fonts/FiraCode-Regular.woff2") format("woff2");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "Dank Mono Regular";
  src: url("/fonts/DankMono-Regular.woff2") format("woff2");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "SourceCode Pro Regular";
  src: url("/fonts/SourceCodePro-Regular.woff2") format("woff2");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "OpenDyslexicMono Regular";
  src: url("/fonts/OpenDyslexicMono-Regular.woff") format("woff");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "OpenDyslexic Regular";
  src: url("/fonts/OpenDyslexic-Regular.woff") format("woff");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "Leelawadee UI Web";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-light.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-light.woff) format("woff");
  font-weight: 100;
  font-style: normal;
}
@font-face {
  font-family: "Leelawadee UI Web";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-semilight.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-semilight.woff) format("woff");
  font-weight: 300;
  font-style: normal;
}
@font-face {
  font-family: "Leelawadee UI Web";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-regular.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-regular.woff) format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Leelawadee UI Web";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-semibold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-semibold.woff) format("woff");
  font-weight: 600;
  font-style: normal;
}
@font-face {
  font-family: "Leelawadee UI Web";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-bold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/leelawadeeui-thai/leelawadeeui-bold.woff) format("woff");
  font-weight: 700;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Arabic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-light.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-light.woff) format("woff");
  font-weight: 100;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Arabic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-semilight.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-semilight.woff) format("woff");
  font-weight: 300;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Arabic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-regular.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-regular.woff) format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Arabic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-semibold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-semibold.woff) format("woff");
  font-weight: 600;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Arabic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-bold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-arabic/segoeui-bold.woff) format("woff");
  font-weight: 700;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Cyrillic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-light.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-light.woff) format("woff");
  font-weight: 100;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Cyrillic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-semilight.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-semilight.woff) format("woff");
  font-weight: 300;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Cyrillic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-regular.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-regular.woff) format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Cyrillic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-semibold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-semibold.woff) format("woff");
  font-weight: 600;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Cyrillic)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-bold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-cyrillic/segoeui-bold.woff) format("woff");
  font-weight: 700;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (East European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-light.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-light.woff) format("woff");
  font-weight: 100;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (East European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-semilight.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-semilight.woff) format("woff");
  font-weight: 300;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (East European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-regular.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-regular.woff) format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (East European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-semibold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-semibold.woff) format("woff");
  font-weight: 600;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (East European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-bold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-easteuropean/segoeui-bold.woff) format("woff");
  font-weight: 700;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Greek)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-light.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-light.woff) format("woff");
  font-weight: 100;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Greek)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-semilight.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-semilight.woff) format("woff");
  font-weight: 300;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Greek)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-regular.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-regular.woff) format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Greek)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-semibold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-semibold.woff) format("woff");
  font-weight: 600;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Greek)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-bold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-greek/segoeui-bold.woff) format("woff");
  font-weight: 700;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Hebrew)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-light.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-light.woff) format("woff");
  font-weight: 100;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Hebrew)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-semilight.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-semilight.woff) format("woff");
  font-weight: 300;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Hebrew)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-regular.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-regular.woff) format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Hebrew)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-semibold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-semibold.woff) format("woff");
  font-weight: 600;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Hebrew)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-bold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-hebrew/segoeui-bold.woff) format("woff");
  font-weight: 700;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Vietnamese)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-light.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-light.woff) format("woff");
  font-weight: 100;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Vietnamese)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-semilight.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-semilight.woff) format("woff");
  font-weight: 300;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Vietnamese)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-regular.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-regular.woff) format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Vietnamese)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-semibold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-semibold.woff) format("woff");
  font-weight: 600;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (Vietnamese)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-bold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-vietnamese/segoeui-bold.woff) format("woff");
  font-weight: 700;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (West European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-light.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-light.woff) format("woff");
  font-weight: 100;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (West European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-semilight.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-semilight.woff) format("woff");
  font-weight: 300;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (West European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-regular.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-regular.woff) format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (West European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-semibold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-semibold.woff) format("woff");
  font-weight: 600;
  font-style: normal;
}
@font-face {
  font-family: "Segoe UI Web (West European)";
  src: url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-bold.woff2) format("woff2"), url(https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-bold.woff) format("woff");
  font-weight: 700;
  font-style: normal;
}
body {
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
}

body button,
body input,
body textarea {
  font-family: inherit;
}

body [lang^=ar],
body[lang^=ar],
[lang^=ar] body {
  font-family: "Segoe UI Web (Arabic)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=bg],
body[lang^=bg],
[lang^=bg] body {
  font-family: "Segoe UI Web (Cyrillic)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=cs],
body[lang^=cs],
[lang^=cs] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=el],
body[lang^=el],
[lang^=el] body {
  font-family: "Segoe UI Web (Greek)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=et],
body[lang^=et],
[lang^=et] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=he],
body[lang^=he],
[lang^=he] body {
  font-family: "Segoe UI Web (Hebrew)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=hi],
body[lang^=hi],
[lang^=hi] body {
  font-family: "Nirmala UI", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=hr],
body[lang^=hr],
[lang^=hr] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=hu],
body[lang^=hu],
[lang^=hu] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=ja],
body[lang^=ja],
[lang^=ja] body {
  font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", Meiryo, "Hiragino Sans", "Source Han Sans", "Noto Sans CJK JP", sans-serif;
}

body [lang^=kk],
body[lang^=kk],
[lang^=kk] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=ko],
body[lang^=ko],
[lang^=ko] body {
  font-family: "Malgun Gothic", Gulim, "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=lo],
body[lang^=lo],
[lang^=lo] body {
  font-family: "Leelawadee UI Web", "Lao UI", DokChampa, "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=lt],
body[lang^=lt],
[lang^=lt] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=lv],
body[lang^=lv],
[lang^=lv] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=pl],
body[lang^=pl],
[lang^=pl] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=ru],
body[lang^=ru],
[lang^=ru] body {
  font-family: "Segoe UI Web (Cyrillic)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=sk],
body[lang^=sk],
[lang^=sk] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=sr-latn],
body[lang^=sr-latn],
[lang^=sr-latn] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=th],
body[lang^=th],
[lang^=th] body {
  font-family: "Leelawadee UI Web", "Kmer UI", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=tr],
body[lang^=tr],
[lang^=tr] body {
  font-family: "Segoe UI Web (East European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=uk],
body[lang^=uk],
[lang^=uk] body {
  font-family: "Segoe UI Web (Cyrillic)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=vi],
body[lang^=vi],
[lang^=vi] body {
  font-family: "Segoe UI Web (Vietnamese)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=zh-hans],
body[lang^=zh-hans],
[lang^=zh-hans] body {
  font-family: "Microsoft Yahei UI", Verdana, Simsun, "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

body [lang^=zh-hant],
body[lang^=zh-hant],
[lang^=zh-hant] body {
  font-family: "Microsoft Jhenghei UI", Pmingliu, "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

.dark-theme {
  --background-color: #262626;
  --text-color: #fff;
  --border-color: #444;
  --background-minor-highlight-color: #343434;
  --inline-code-background-color: rgb(58, 58, 92, 0.7);
  --inline-code-color: #fff;
  --link-color: #719af4;
  --pure-background: black;
  --raised-background-color: #313131;
  --alt-text-color: #fff;
  --raised-box-shadow: 0 1.6px 3.6px 0 rgba(255, 255, 255, 0.132),
    0 0.3px 0.9px 0 rgba(255, 255, 255, 0.108);
  --sidebar-background-color: #2a2a2b;
  --sidebar-list-active-background-color: #28323a;
  --sidebar-list-background-color: rgb(53, 52, 52);
  --sidebar-link-border-color: #fff;
  --sidebar-item-border-color: #3e3e3e;
  --sidebar-active-button-background-color: #4e4e4f;
  --table-border-color: #545454;
  --blue-tinged-bg: #2c3841;
  --blue-tinged-strong: #273f52;
  --footer-arrow-color: $ts-light-bg-grey-highlight-color;
  --fade-gradient: linear-gradient(
    0deg,
    rgba(49, 49, 49, 1) 0%,
    rgba(49, 49, 49, 0.2) 100%
  );
}

html,
html.light-theme {
  --background-color: #faf9f8;
  --pure-background: white;
  --text-color: #333;
  --border-color: #eee;
  --background-minor-highlight-color: #fcfcfc;
  --inline-code-background-color: #f5f2f0;
  --inline-code-color: #000;
  --link-color: #235a97;
  --raised-background-color: #fff;
  --alt-text-color: #000;
  --raised-box-shadow: 0 1.6px 3.6px 0 rgba(0, 0, 0, 0.132),
    0 0.3px 0.9px 0 rgba(0, 0, 0, 0.108);
  --sidebar-background-color: #eeeeee;
  --sidebar-list-active-background-color: #d3dde3;
  --sidebar-list-background-color: #dedede;
  --sidebar-link-border-color: #000;
  --sidebar-item-border-color: #dfdfdf;
  --sidebar-active-button-background-color: #dfdfdf;
  --footer-arrow-color: $ts-dark-bg-for-foreground-color;
  --table-border-color: #f1f1f1;
  --blue-tinged-bg: #e6f2fb;
  --blue-tinged-strong: #cce4f6;
  --fade-gradient: linear-gradient(
    0deg,
    rgba(255, 255, 255, 1) 0%,
    rgba(255, 255, 255, 0.2) 100%
  );
  background-color: var(--background-color);
  color: var(--text-color);
  -webkit-font-smoothing: antialiased;
  font-family: var(--body-font);
  font-size: 16px;
  line-height: 1.4;
}

html {
  --code-font: "Cascadia Mono-SemiLight", Menlo, Monaco, Consolas, monospace;
  --body-font: "Segoe UI Web (West European)", "Segoe UI", -apple-system,
    BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
}

html.font-cascadia-ligatures {
  --code-font: "Cascadia Code-SemiLight", Menlo, Monaco, Consolas, monospace;
}

html.font-consolas {
  --code-font: Consolas, monospace;
}

html.font-dank-mono {
  --code-font: "Dank Mono Regular", Menlo, Monaco, Consolas, monospace;
}

html.font-jetbrains-mono {
  --code-font: "JetBrains Mono-Regular", Menlo, Monaco, Consolas, monospace;
}

html.font-fira-code {
  --code-font: "FiraCode-Regular", Menlo, Monaco, Consolas, monospace;
}

html.font-sf-mono {
  --code-font: "SF Mono", Menlo, Monaco, Consolas, monospace;
}

html.font-source-code-pro {
  --code-font: "SourceCode Pro Regular", Menlo, Monaco, Consolas, monospace;
}

html.font-open-dyslexic {
  --code-font: "OpenDyslexicMono Regular", Menlo, Monaco, Consolas, monospace;
  --body-font: "OpenDyslexic Regular", "Segoe UI Web (West European)",
    "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue",
    sans-serif;
}

.raised {
  box-shadow: var(--raised-box-shadow);
  background-color: var(--raised-background-color);
  color: var(--alt-text-color);
  /**************
    We are using a slightly modified Prism default color scheme defined
    in prism-var-lf.css.  If you want to change the background colors
    by language, we can do that here.

  .language-lf {
    background-color: rgb(220, 220, 220) !important;
    // dark: background-color: rgb(35, 35, 35) !important;
  }
  .language-lf-c {
    background-color: rgb(219, 236, 255) !important;
    // dark: background-color: rgb(0, 49, 100) !important;
  }
  .language-lf-cpp {
    background-color: rgb(0, 60, 15) !important;
  }
  .language-lf-py {
    background-color: rgb(60, 43, 13) !important;
  }
  .language-lf-ts {
    background-color: rgb(60, 13, 58) !important;
  }
  .language-lf-rs {
    background-color: rgb(60, 30, 13) !important;
  }
  .lf {
    background-color: rgb(220, 220, 220) !important;
  }
  .lf-c {
    background-color: rgb(219, 236, 255) !important;
  }
  .lf-cpp {
    background-color: rgb(226, 255, 233) !important;
  }
  .lf-py {
    background-color: rgb(242, 229, 221) !important;
  }
  .lf-ts {
    background-color: rgb(255, 239, 254) !important;
  }
  .lf-rs {
    background-color: rgb(255, 237, 227) !important;
  }
  */
  /* LF keywords are defined in gatsby-config.js. */
}
.raised a {
  color: var(--link-color);
}
.raised h1,
.raised h2,
.raised h3 {
  margin-top: 2rem;
  margin-bottom: 1.5rem;
  line-height: normal;
}
.raised p,
.raised li {
  line-height: 1.4rem;
}
.raised ul {
  padding-left: 10px;
}
.raised ul li {
  margin-left: 10px;
  margin-bottom: 10px;
}
.raised h1 > code,
.raised h2 > code,
.raised h3 > code {
  background-color: var(--inline-code-background-color);
  color: var(--inline-code-color);
  font-size: 0.95em;
  margin-top: 0.2em;
  margin-left: 0.2em;
  margin-right: 0.2em;
  padding: 2px 4px;
}
.raised p > code,
.raised li > code {
  background-color: var(--inline-code-background-color);
  color: var(--inline-code-color);
  font-family: var(--code-font);
  font-size: 0.9rem;
  padding: 2px 4px;
}
.raised td {
  padding: 4px;
}
.raised .lf_keywords {
  color: rgb(196, 130, 14) !important;
  font-weight: bold;
}
.raised .web-page-error {
  color: red !important;
  font-weight: bold;
}

/* Spans marked with class "lf" are treated as keywords. */
.lf {
  color: rgb(196, 130, 14) !important;
  font-weight: bold;
}

.dark-theme .raised .markdown .anchor.before svg path {
  fill: #fff;
}

h2,
h3 {
  font-weight: 400;
}

.main-content-block {
  max-width: 960px;
  margin: 1rem auto;
  padding: 2rem;
  padding-top: 0.4rem;
}
.main-content-block.headline {
  max-width: calc(960px + 4rem);
}

body {
  margin: 0;
  height: 100%;
}

html,
#___gatsby {
  height: 100%;
}

#site-wrapper {
  display: flex;
  flex-direction: column;
}

#beta {
  background: repeating-linear-gradient(45deg, #9b9a4e, #9b9a4e 10px, #6e6a33 10px, #6e6a33 20px);
  background-color: "#c63131";
  text-align: center;
  color: white;
  text-shadow: 0px 2px 4px black;
  padding: 4px;
  padding-bottom: 6px;
}

#doc-layout {
  display: flex;
  flex-direction: row;
}

#handbook-content {
  margin: auto;
  padding: 0 2rem;
  max-width: 1200px;
  min-width: 0;
}
@media (max-width: 480px) {
  #handbook-content {
    padding: 0;
  }
}
#handbook-content > h2 {
  font-size: 3.5rem;
  line-height: 3.5rem;
  font-weight: 400;
  letter-spacing: 0rem;
}
@media (max-width: 800px) {
  #handbook-content > h2 {
    margin-left: 1rem;
    margin-right: 1rem;
    font-size: 2.5rem;
  }
}
#handbook-content article {
  display: flex;
  width: 100%;
}
#handbook-content .whitespace,
#handbook-content .whitespace-tight {
  margin: 1rem auto;
  margin-top: 0;
  padding: 2rem;
  overflow: hidden;
}
#handbook-content .whitespace-tight {
  padding: 1.2rem 2rem;
}
#handbook-content aside {
  display: none;
  width: 13rem;
  flex-shrink: 0;
  margin-left: 20px;
}
@media (min-width: 1000px) {
  #handbook-content aside {
    display: block;
  }
}
#handbook-content aside nav {
  position: sticky;
  top: 30px;
  margin-bottom: 1rem;
}
#handbook-content aside nav.deprecated {
  top: 7rem;
}
#handbook-content aside h5 {
  font-weight: 600;
  font-size: 16px;
  margin: 0;
}
#handbook-content aside ul {
  padding: 0;
}
#handbook-content aside ul li {
  list-style: none;
}
#handbook-content aside ul a {
  font-weight: normal;
  font-size: 14px;
  color: var(--alt-text-color);
  text-decoration: none;
  border-left: 2px solid transparent;
  padding-left: 8px;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
  display: block;
}
#handbook-content aside ul a:hover, #handbook-content aside ul a:active {
  border-left: 2px solid rgba(0, 120, 212, 0.3);
}
#handbook-content aside ul a.current {
  border-left: 2px solid #0078d4;
}
#handbook-content aside .like-dislike-subnav #like-button,
#handbook-content aside .like-dislike-subnav #dislike-button {
  cursor: pointer;
}
#handbook-content .preamble a {
  color: var(--text-color);
}
#handbook-content .justify-between {
  justify-content: space-between;
}
#handbook-content a.navigation-link {
  text-decoration: none;
  flex: 1;
}
#handbook-content .prev-next {
  flex: 1;
}
#handbook-content .prev-next .arrow {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  margin-right: 20px;
}
#handbook-content .prev-next header,
#handbook-content .prev-next h3,
#handbook-content .prev-next p {
  padding: 0;
  margin: 0;
}
#handbook-content .prev-next header {
  margin-bottom: 0.5rem;
  font-size: 0.8rem;
}
#handbook-content .prev-next p {
  margin-bottom: 0.4rem;
}
#handbook-content .prev-next p,
#handbook-content .prev-next header {
  color: var(--text-color);
}
#handbook-content .prev-next:hover svg path, #handbook-content .prev-next:hover h3 {
  fill: var(--text-color);
  color: var(--text-color);
}
#handbook-content .prev-next .nav-content {
  flex: 1;
  padding-right: 1rem;
}
#handbook-content .prev-next.next {
  flex-direction: row-reverse;
  text-align: right;
  padding-right: 0;
  padding-left: 1rem;
}
#handbook-content .prev-next.next .arrow {
  margin-right: 0px;
  margin-left: 20px;
}
#handbook-content .prev-next.next svg {
  transform: scaleX(-1);
}
#handbook-content .vertical-line {
  height: 80px;
  background-color: #e3e3e3;
  min-width: 2px;
  flex-basis: 2px;
  flex-grow: 0;
  flex-shrink: 0;
}
#handbook-content .docs-footer {
  height: 2rem;
  margin: 0 -2rem;
  padding: 0 0;
  border-top: var(--border-color) 1px solid;
  display: flex;
  flex-direction: row-reverse;
}
#handbook-content .docs-footer h5 {
  margin: 0;
  padding: 0;
  padding-top: 0.5rem;
  padding-right: 1rem;
  font-weight: normal;
}
#handbook-content .docs-footer button {
  border: none;
  background: none;
  display: inline-flex;
  flex-direction: row;
  align-items: center;
  color: var(--text-color);
  border-left: 1px solid var(--border-color);
  padding: 0 1rem;
  cursor: pointer;
}
#handbook-content .docs-footer button:hover {
  background-color: var(--border-color);
}
#handbook-content .docs-footer button svg {
  margin-right: 4px;
  fill: var(--text-color);
  color: var(--text-color);
}
#handbook-content #deprecated-header {
  color: black;
  background-color: #fff4cf;
  margin: 0 -2rem;
  padding: 1rem 2rem 1rem 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  z-index: 1;
}
#handbook-content #deprecated-header [id]::before {
  height: 110px;
  margin-top: -110px;
}
@media (max-width: 800px) {
  #handbook-content #deprecated-header {
    margin: 0 0 0 0;
    padding: 1rem;
    flex-direction: column;
  }
  #handbook-content #deprecated-header h3 {
    font-size: 0.8rem;
  }
  #handbook-content #deprecated-header #deprecated-icon {
    margin-right: 1rem;
  }
  #handbook-content #deprecated-header #deprecated-action {
    margin-top: 1rem;
  }
}
#handbook-content #deprecated-header #deprecated-content {
  display: flex;
  align-items: center;
}
#handbook-content #deprecated-header #deprecated-content #deprecated-icon {
  width: 2rem;
  text-align: center;
}
#handbook-content #deprecated-header h3 {
  margin-top: 0;
  font-weight: normal;
  font-size: 1.5rem;
  margin-bottom: 0.5rem;
}
#handbook-content #deprecated-header p {
  margin-top: 0;
  margin-bottom: 0.2rem;
}
#handbook-content #deprecated-header #deprecated-action {
  flex-shrink: 0;
}
#handbook-content #deprecated-header #deprecated-action a {
  padding: 0.2rem 0.5rem;
  background-color: white;
  border: 1px solid black;
  text-decoration: none;
  color: black;
}
#handbook-content #deprecated-header #deprecated-action a:hover {
  background-color: #eee;
}
#handbook-content .markdown table.cli-option {
  display: table;
}
#handbook-content .markdown table.cli-option tr {
  width: 100%;
}
#handbook-content .markdown table.cli-option tr p {
  margin: 0;
  padding: 0;
}
#handbook-content .markdown table.cli-option tr code {
  word-wrap: normal;
}
#handbook-content .markdown table.cli-option tr.odd {
  background-color: var(--background-color) !important;
}
#handbook-content .markdown table.cli-option tr.even {
  background-color: var(--background-minor-highlight-color) !important;
}
#handbook-content .markdown table.cli-option ul {
  margin: 0;
  padding: 0;
}
#handbook-content .markdown table.cli-option ul li {
  list-style: none;
  margin: 0;
  margin-bottom: 8px;
}
#handbook-content .markdown table.cli-option tr.option-description td {
  margin-top: 0;
  border-top: none;
}

.circle-bg {
  background-color: #719af4;
  color: black;
  width: 32px;
  height: 32px;
  line-height: 31px;
  border-radius: 16px;
  text-align: center;
  display: inline-block;
  position: relative;
  margin-top: 12px;
  margin-right: 3px;
}
.circle-bg img {
  position: absolute;
  top: 0;
  left: 0;
  border-radius: 16px;
  width: 32px;
  height: 32px;
}

.bottom-section-content {
  flex: 1;
  padding: 1rem 2rem;
}

@media (max-width: 480px) {
  .small-columns {
    flex-direction: column !important;
  }
}

.inline-popup {
  background: var(--background-color);
  position: absolute;
  z-index: 110;
  box-shadow: 0 30px 90px -20px rgba(0, 0, 0, 0.3), 0 0 1px 1px rgba(0, 0, 0, 0.05);
  padding: 0;
  font-size: 14px;
  line-height: 20px;
  min-width: 300px;
  max-width: 400px;
  border-radius: 2px;
  transition: opacity 0.5s;
}
.inline-popup .inline-popup-container {
  display: flex;
}
.inline-popup .inline-popup-container a.inline-popup-extract {
  max-height: 140px;
  overflow: hidden;
  margin: 16px;
  display: block;
  color: var(--text-color);
  text-decoration: none;
  position: relative;
}
.inline-popup .inline-popup-container a.inline-popup-extract h5 {
  margin-top: 0;
}
.inline-popup .inline-popup-container a.inline-popup-extract::after {
  content: " ";
  position: absolute;
  bottom: 0;
  width: 25%;
  height: 20px;
  background-color: transparent;
  pointer-events: none;
}
.inline-popup .inline-popup-container a.inline-popup-extract div {
  margin: 0;
}
.inline-popup .inline-popup-container a.inline-popup-extract div code {
  background-color: var(--inline-code-background-color);
  border-radius: 2px;
  padding: 2px 4px;
}
.inline-popup.popup-fade-in {
  -webkit-animation: 0.1s ease forwards;
  animation: 0.1s ease forwards;
}

.markdown {
  scroll-behavior: smooth;
}
.markdown h1,
.markdown h2,
.markdown h3 {
  display: flex;
  flex-wrap: wrap;
  font-weight: 400;
  line-height: 1.3;
}
.markdown h1 a,
.markdown h2 a,
.markdown h3 a {
  padding-right: 10px !important;
}
.markdown h1[id]::before,
.markdown h2[id]::before,
.markdown h3[id]::before {
  content: "";
  display: block;
  visibility: hidden;
  height: 30px;
  margin-top: -30px;
}
.markdown h1 {
  margin-bottom: 12px;
  font-size: 2rem;
  margin-top: 0;
  word-wrap: break-word;
  word-break: break-word;
}
.markdown h2 {
  font-size: 1.75rem;
  margin-bottom: 12px;
  margin-top: 32px;
}
.markdown h3 {
  font-size: 1.1875rem;
  margin-top: 30px;
  margin-bottom: 18px;
}
.markdown pre {
  clear: both;
  top: 10px;
}
.markdown blockquote {
  border-left: 2px solid var(--border-color);
  background-color: var(--inline-code-background-color);
  font-size: 0.8rem;
  margin: auto;
  padding: 0.1rem 2rem;
}
.markdown blockquote.bg-reading {
  float: right;
  margin-left: 0.5rem;
  border-left: none;
}
.markdown .language-id {
  display: none;
}
.markdown table {
  max-width: 100%;
  width: 100%;
  overflow-x: auto;
  display: block;
  table-layout: auto;
  font-size: 0.875rem;
  border-collapse: separate;
  border-spacing: 0;
}
.markdown table.data {
  display: table;
}
.markdown table.data td,
.markdown table.data th,
.markdown table.data tr {
  text-align: center;
}
.markdown table td,
.markdown table th {
  text-align: left;
  display: table-cell;
  word-wrap: break-word;
  padding: 0.75rem 1rem;
  line-height: 1.5;
  vertical-align: top;
  border-top: 1px solid hsl(0deg, 0%, 89%);
  border-top: 1px solid var(--border-color);
  border-right: 0;
  border-left: 0;
  border-bottom: 0;
  border-style: solid;
}
.markdown table tr:nth-child(2n) {
  background-color: var(--background-minor-highlight-color);
}
.markdown table th {
  border-top: none;
}
.markdown img {
  max-width: 100%;
}
.markdown table.full-width-table {
  width: 100%;
  display: table;
}
.markdown .blue-tick {
  color: #3178c6;
  font-weight: bold;
  font-size: 1.2rem;
}
.markdown .black-tick {
  color: #086f56;
  font-size: 1.2rem;
}
.markdown .red-cross {
  color: #c63131;
  font-size: 1.2rem;
}
      .language-lf-c {
        display: none; /* Don't show for this PDF */
      }
      .lf-c {
        display: none; /* Don't show for this PDF */
      }
      
      .language-lf-cpp {
        display: none; /* Don't show for this PDF */
      }
      .lf-cpp {
        display: none; /* Don't show for this PDF */
      }
      
      .language-lf-py {
        display: block; /* Shows for this PDF. */
      }
      .lf-py {
        display: inline; /* Shows for this PDF. */
      }
      
      .language-lf-ts {
        display: none; /* Don't show for this PDF */
      }
      .lf-ts {
        display: none; /* Don't show for this PDF */
      }
      
      .language-lf-rs {
        display: none; /* Don't show for this PDF */
      }
      .lf-rs {
        display: none; /* Don't show for this PDF */
      }
      
html {
  background-color: #EEEEEE;
}

body {
  padding-top: 5rem;
  -webkit-print-color-adjust: exact !important;
}

article {
  page-break-after: always;
  margin-bottom: 4rem;
}

pre {
  page-break-inside:avoid
}

.raised {
  box-shadow: none;
}

#pdf-intro {
  page-break-after: always
}

#pdf-intro table {
  width: 600px;
  margin: 0 auto;
}

pre .error-behind {
  color: white;
}

    </style></head><body><div id='handbook-content'>
  <div id="pdf-intro">
  <center style="page-break-after: always">
    <img src="./Lingua_Franca.png" width=200>
    <p style='width: 340px;'>This copy of the Lingua Franca handbook for the py target was created on Thursday, April 14, 2022 against
    commit
    <a href="https://github.com/lf-lang/website-lingua-franca/tree/9d6080"><code>9d6080</code></a>.
    </p>
  </center>
  <h1 style='margin: 0 2rem; margin-bottom: 4rem;'>Table of Contents</h1><table><tbody><tr><td style='width: 200px;'><a href="#title-0">A First Reactor</a></td><td>Writing your first Lingua Franca reactor.</td></tr>
<tr><td style='width: 200px;'><a href="#title-1">Inputs and Outputs</a></td><td>Inputs, outputs, and reactions in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-2">Parameters and State Variables</a></td><td>Parameters and state variables in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-3">Time and Timers</a></td><td>Time and timers in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-4">Composing Reactors</a></td><td>Composing reactors in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-5">Reactions and Methods</a></td><td>Reactions and methods in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-6">Causality Loops</a></td><td>Causality loops in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-7">Extending Reactors</a></td><td>Extending reactors in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-8">Actions</a></td><td>Actions in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-9">Superdense Time</a></td><td>Superdense time in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-10">Deadlines</a></td><td>Deadlines in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-11">Multiports and Banks</a></td><td>Multiports and Banks of Reactors.</td></tr>
<tr><td style='width: 200px;'><a href="#title-12">Preambles and Methods</a></td><td>Defining functions and methods in Lingua Franca.</td></tr>
<tr><td style='width: 200px;'><a href="#title-13">Distributed Execution</a></td><td>Distributed Execution (preliminary)</td></tr>
<tr><td style='width: 200px;'><a href="#title-14">Termination</a></td><td>Terminating a Lingua Franca execution.</td></tr></tbody></table></div><h1 style='margin: 0 2rem' id='title-0'>A First Reactor</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.
<span class="lf-c">
See <a href="setup-for-c">setup for C</a>.
</span>
<span class="lf-cpp">
See <a href="setup-for-cpp">setup for C++</a>.
</span>
<span class="lf-py">
See <a href="setup-for-python">setup for Python</a>.
</span>
<span class="lf-ts">
See <a href="setup-for-typescript">setup for TypeScript</a>.
</span>
<span class="lf-rs">
See <a href="setup-for-rust">setup for Rust</a>.
</span></p>
<h2>Minimal Example</h2>
<p>A minimal but complete Lingua Franca file with one reactor is this:</p>
<p></p>
<pre><code class="language-lf-c">target C;
main reactor {
    reaction(startup) {=
        printf("Hello World.\n");
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">target Cpp;
main reactor {
    reaction(startup) {=
        cout &#x3C;&#x3C; "Hello World.\n";
    =}
}
</code></pre>
<pre><code class="language-lf-py">target Python;
main reactor {
    reaction(startup) {=
        print("Hello World.")
    =}
}
</code></pre>
<pre><code class="language-lf-ts">target TypeScript;
main reactor {
    reaction(startup) {=
        console.log("Hello World.");
    =}
}
</code></pre>
<pre><code class="language-lf-rs">target Rust;
main reactor {
    reaction(startup) {=
        println!("Hello World.");
    =}
}
</code></pre>
<p></p>
<p>Every Lingua Franca program begins with a <a href="target-specification">target specification</a> that specifies the language in which reactions are written. This is also the language of the program(s) generated by the Lingua Franca code generator.</p>
<p>Every LF program also has a <span class="lf_keywords">main</span> <span class="lf-c lf-py lf-ts"> or <span class="lf_keywords">federated</span></span> reactor, which is the top level of a hierarchy of contained and interconnected reactors. The above simple example has no contained reactors.</p>
<p>The <span class="lf_keywords">main</span> reactor above has a single <span class="lf_keywords">reaction</span>, which is triggered by the <span class="lf_keywords">startup</span> trigger. This trigger causes the reaction to execute at the start of the program. The body of the reaction, delimitted by <code>{= ... =}</code>, is ordinary <span class="lf-c">C</span><span class="lf-cpp">Cpp</span><span class="lf-py">Python</span><span class="lf-ts">TypeScript</span><span class="lf-rs">Rust</span> code which, as we will see, has access to a number of functions and variables specific to Lingua Franca.</p>
<h2>Structure of an LF Project</h2>
<p>The Lingua Franca tools assume that LF programs are put into a file with a <code>.lf</code> extension that is stored somewhere within a directory called <code>src</code>. To compile and run the above example, choose a <strong>project root</strong> directory, create a <code>src</code> directory within that, and put the above code into a file called, say, <code>src/HelloWorld.lf</code>. You can compile the code on the <a href="command-line-tools">command line</a>, within <a href="code-plugin">Visual Studio Code</a>, or within the <a href="epoch-ide">Epoch IDE</a>. On the command line this will look like this:</p>
<pre><code>    > lfc src/Minimal.lf
    ... output from the code generator and compiler ...
</code></pre>
<div class="lf-c lf-cpp lf-rs">
<p>After this completes, two additional directories will have been created within the projet root, <code>bin</code> and <code>src-gen</code>. The <code>bin</code> directory has an executable file called <code>HelloWorld</code>. Executing that file will result, not surprisingly, in printing "Hello World". The generated source files will be within the directory <code>src-gen</code>.</p>
</div>
<div class="lf-ts lf-py">
<p>After this completes, an additional <code>src-gen</code> directory will have been created within the projet root. The generated code will be in subdirectory called <code>HelloWorld</code> within <code>src-gen</code>. The output from the code generator will include instructions for executing the generated code:</p>
<pre><code class="language-lf-ts">#####################################
To run the generated program, use:

    node ...path-to-project.../src-gen/Minimal/Minimal.js

#####################################
</code></pre>
<pre><code class="language-lf-py">#####################################
To run the generated program, use:

    python3 ...path-to-project.../src-gen/Minimal/Minimal.py

#####################################
</code></pre>
</div>
<h2>Reactor Block</h2>
<p>A <span class="lf_keywords">reactor</span> is a software component that reacts to input events, timer events, and internal events. It has private state variables that are not visible to any other reactor. Its reactions can consist of altering its own state, sending messages to other reactors, or affecting the environment through some kind of actuation or side effect (e.g., printing a message, as in the above <code>HelloWorld</code> example).</p>
<p>The general structure of a reactor definition is as follows:</p>
<div class="lf-c lf-ts">
<pre><code class="language-lf">[main or federated] reactor &#x3C;class-name> [(&#x3C;parameters>)] {
    input &#x3C;name>:&#x3C;type>
    output &#x3C;name>:&#x3C;type>
    state &#x3C;name>:&#x3C;type>(&#x3C;value>)
    timer &#x3C;name>([&#x3C;offset>, [&#x3C;period>]])
    logical action &#x3C;name>[:&#x3C;type>]
    physical action &#x3C;name>[:&#x3C;type>]
    reaction(&#x3C;triggers>) [&#x3C;uses>] [=> &#x3C;effects>] {= ... body ...=}
    &#x3C;instance-name> = new &#x3C;class-name>([&#x3C;parameter-assignments>])
    &#x3C;instance-name> [, ...] => &#x3C;instance-name> [, ...] [after &#x3C;delay>]
}
</code></pre>
</div>
<div class="lf-cpp lf-rs">
<pre><code class="language-lf">[main] reactor &#x3C;class-name> [(&#x3C;parameters>)] {
    input &#x3C;name>:&#x3C;type>
    output &#x3C;name>:&#x3C;type>
    state &#x3C;name>:&#x3C;type>(&#x3C;value>)
    timer &#x3C;name>([&#x3C;offset>, [&#x3C;period>]])
    logical action &#x3C;name>[:&#x3C;type>]
    physical action &#x3C;name>[:&#x3C;type>]
    [const] method &#x3C;name>(&#x3C;parameters>):&#x3C;type> {= ... body ...=}
    reaction(&#x3C;triggers>) [&#x3C;uses>] [=> &#x3C;effects>] {= ... body ...=}
    &#x3C;instance-name> = new &#x3C;class-name>([&#x3C;parameter-assignments>])
    &#x3C;instance-name> [, ...] => &#x3C;instance-name> [, ...] [after &#x3C;delay>]
}
</code></pre>
</div>
<div class="lf-py">
<pre><code class="language-lf">[main or federated] reactor &#x3C;class-name> [(&#x3C;parameters>)] {
    input &#x3C;name>
    output &#x3C;name>
    state &#x3C;name>(&#x3C;value>)
    timer &#x3C;name>([&#x3C;offset>, [&#x3C;period>]])
    logical action &#x3C;name>
    physical action &#x3C;name>
    [const] method &#x3C;name>(&#x3C;parameters>) {= ... body ...=}
    reaction(&#x3C;triggers>) [&#x3C;uses>] [=> &#x3C;effects>] {= ... body ...=}
    &#x3C;instance-name> = new &#x3C;class-name>([&#x3C;parameter-assignments>])
    &#x3C;instance-name> [, ...] => &#x3C;instance-name> [, ...] [after &#x3C;delay>]
}
</code></pre>
</div>
<p>Contents within square brackets are optional, contents within <code>&#x3C;...></code> are user-defined, and each line may appear zero or more times, as explained in the next pages. Parameters, inputs, outputs, timers, actions, and contained reactors all have names, and the names are required to be distinct from one another.</p>
<p>If the <span class="lf_keywords">reactor</span> keyword is preceded by <span class="lf_keywords">main</span><span class="lf-c lf-py lf-ts"> or <span class="lf_keywords">federated</span></span>, then this reactor will be instantiated and run by the generated code.</p>
<p>Any number of reactors may be defined in one file, and a <span class="lf_keywords">main</span><span class="lf-c lf-py lf-ts"> or <span class="lf_keywords">federated</span></span> reactor need not be given a name, but if it is given a name, then that name must match the file name.</p>
<p>Reactors may extend other reactors, inheriting their properties, and a file may import reactors from other files. If an imported LF file contains a <span class="lf_keywords">main</span><span class="lf-c lf-py lf-ts"> or <span class="lf_keywords">federated</span></span> reactor, that reactor is ignored (it will not be imported). This makes it easy to create a library of reusable reactors that each come with a test case or demonstration in the form of a main reactor.</p>
<h2>Comments</h2>
<p>Lingua Franca files can have C/C++/Java-style comments and/or Python-style comments. All of the following are valid comments:</p>
<pre><code class="language-lf">    // Single-line C-style comment.
    /*
     * Multi-line C-style comment.
     */
    # Single-line Python-style comment.
    '''
       Multi-line Python-style comment.
    '''
</code></pre></div></div></article><h1 style='margin: 0 2rem' id='title-1'>Inputs and Outputs</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<p>In this section, we will endow reactors with inputs and outputs.</p>
<h2>Input and Output Declarations</h2>
<p>Input and output declarations have the form:</p>
<div class="lf-c lf-ts lf-rs lf-cpp">
<pre><code class="language-lf">    input &#x3C;name>:&#x3C;type>
    output &#x3C;name>:&#x3C;type>
</code></pre>
</div>
<div class="lf-py">
<pre><code class="language-lf">    input &#x3C;name>
    output &#x3C;name>
</code></pre>
</div>
<p>For example, the following reactor doubles its input and sends the result to the output:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Double {
    input x:int;
    output y:int;
    reaction(x) -> y {=
        SET(y, x->value * 2);
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">target Cpp;
reactor Double {
    input x:int;
    output y:int;
    reaction(x) -> y {=
        y.set(x.value * 2);
    =}
}
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Double.lf

</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Double.lf

</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Double.lf

</code></pre>
<p></p>
<p>Notice how the input value is accessed and how the output value is set. This is done differently for each target language. See
<span class="lf-c"><a href="https://www.typescriptlang.org/docs/handbook/c-reactors">C Reactors</a></span>
<span class="lf-cpp"><a href="https://www.typescriptlang.org/docs/handbook/cpp-reactors">C++ Reactors</a></span>
<span class="lf-py"><a href="https://www.typescriptlang.org/docs/handbook/python-reactors">Python Reactors</a></span>
<span class="lf-ts"><a href="https://www.typescriptlang.org/docs/handbook/typescript-reactors">TypeScriupt Reactors</a></span>
<span class="lf-rs"><a href="https://www.typescriptlang.org/docs/handbook/rust-reactors">Rust Reactors</a></span>
for detailed documentation of these mechanisms.</p>
<div class="lf-c lf-cpp lf-ts lf-rs">
<p>The <strong>type</strong> of a port is a type in the target language plus the special type <span class="lf_keywords">time</span>. A type may also be specified using a <strong>code block</strong>, delimited by the same delimeters <code>{= ... =}</code> that separate target language code from Lingua Franca code in reactions. Any valid target-language type designator can be given within these delimiters. See <a href="https://www.typescriptlang.org/docs/handbook/lingua-franca-types">Lingua Franca Types</a> for details.</p>
</div>
<h2>Triggers, Effects, and Uses</h2>
<p>The <span class="lf_keywords">reaction</span> declaration above indicates that an input event on port <code>x</code> is a <strong>trigger</strong> and that an output event on port <code>y</code> is a (potential) <strong>effect</strong>. A reaction can declare more than one trigger or effect by just listing them separated by commas. For example, the following reactor has two triggers and tests each input for presence before using it:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Destination {
    input x:int;
    input y:int;
    reaction(x, y) {=
        int sum = 0;
        if (x->is_present) {
            sum += x->value;
        }
        if (y->is_present) {
            sum += y->value;
        }
        printf("Received %d.\n", sum);
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Destination.lf

</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Destination.lf

</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Destination.lf

</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Destination.lf

</code></pre>
<p></p>
<p><strong>NOTE:</strong> if a reaction fails to test for the presence of an input and reads its value anyway, then the result it will get is target dependent.
<span class="lf-c">In the C target, the value read will be the most recently seen input value, or, if no input event has occurred at an earlier logical time, then zero or NULL, depending on the datatype of the input.</span>
<span class="lf-cpp warning">FIXME.</span>
<span class="lf-py warning">FIXME.</span>
<span class="lf-ts">In the TS target, the value will be <strong>undefined</strong>, a legitimate value in TypeScript.</span>
<span class="lf-rs warning">FIXME.</span></p>
<h2>Reactions</h2>
<p>The general form of a <span class="lf_keywords">reaction</span> is</p>
<pre><code class="language-lf">reaction (&#x3C;triggers>) &#x3C;uses> -> &#x3C;effects> {=
    &#x3C;target language code>
=}
</code></pre>
<p>The <strong>triggers</strong> field can be a comma-separated list of input ports, <a href="https://www.typescriptlang.org/docs/handbook/hierarchy">output ports of contained reactors</a>, <a href="https://www.typescriptlang.org/docs/handbook/timers-and-actions">timers, actions</a>, or the special events <span class="lf_keywords">startup</span> and <span class="lf_keywords">shutdown</span>. There must be at least one trigger for each reaction. A reaction with a <span class="lf_keywords">startup</span> trigger is invoked when the program begins executing, and a reaction with a <span class="lf_keywords">shutdown</span> trigger is invoked at the end of execution.</p>
<p>The <strong>uses</strong> field, which is optional, specifies input ports (or <a href="https://www.typescriptlang.org/docs/handbook/hierarchy">output ports of contained reactors</a>) that do not trigger execution of the reaction but may be read by the reaction.</p>
<p>The <strong>effects</strong> field, which is also optional, is a comma-separated lists of output ports ports, <a href="https://www.typescriptlang.org/docs/handbook/hierarchy">input ports of contained reactors</a>, or <a href="https://www.typescriptlang.org/docs/handbook/timers-and-actions">actions</a>.</p>
<h2>Mutable Inputs</h2>
<p>Normally, a reaction does not modify the value of an input. An input is said to be <strong>immutable</strong>. The degree to which this is enforced varies by target language. Most of the target languages make it rather difficult to enforce, so the programmer needs to avoid modifying the input. Modifying an input value may lead to nondeterministic results.</p>
<p>Occassionally, it is useful to modify an input. For example, the input may be a large data structure, and a reaction may wish to make a small modification and forward the result to an output. To accomplish this, the programmer should declare the input <strong>mutable</strong> as follows:</p>
<div class="lf-c lf-cpp lf-ts lf-rs>
<pre><code class="language-lf">    mutable input &#x3C;name>:&#x3C;type>;
</code></pre>
</div>
<div class="lf-py>
<pre><code class="language-lf">    mutable input &#x3C;name>;
</code></pre>
</div>
<p>This is a directive to the code generator indicating that reactions that read this input may also modify the value of the input. The code generator will attempt to optimize the scheduling to avoid copying the input value, but this may not be possible, in which case it will automatically insert a copy operation, making it safe to modify the input. The target-spefic reference documentation has more details about how this works.</p></div></div></article><h1 style='margin: 0 2rem' id='title-2'>Parameters and State Variables</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<h2>Parameter Declaration</h2>
<p>A reactor class definition can parameterized as follows:</p>
<div class="lf-c lf-cpp lf-ts lf-rs">
<pre><code class="language-lf">reactor &#x3C;class-name>(&#x3C;param-name>:&#x3C;type>(&#x3C;expr>), ...) {
    ...
}
</code></pre>
<p>Each parameter has a <em>type annotation</em>, written <code>:&#x3C;type></code>, where <code>&#x3C;type></code> has one of the following forms:</p>
<ul>
<li>An identifier, such as <code>int</code><span class="lf-cpp">, possibly followed by a type argument, e.g. <code>vector&#x3C;int></code></span>.</li>
<li>An array type <code>type[]</code><span class="lf-c lf-cpp lf-rs"> and <code>type[integer]</code></span>.</li>
<li>The keyword <span class="lf_keywords">time</span>, which designates a time value.</li>
<li>A code block delimitted by <code>{= ... =}</code>, where the contents is any valid type in the target language.</li>
</ul>
</div>
<div class="lf-c lf-cpp">
<ul>
<li>A pointer type, such as <code>int*</code>.</li>
</ul>
</div>
<div class="lf-c">
<p>Types ending with a <code>*</code> are treated specially by the C target. See <a href="https://www.typescriptlang.org/docs/handbook/c-reactors#sending-and-receiving-arrays-and-structs">Sending and Receiving Arrays and Structs</a> in the C target documentation.</p>
<p>To use strings conveniently in the C target, the "type" <code>string</code> is an alias for <code>{=const char*=}</code>.</p>
</div>
<div class="lf-ts">
<p>For example, <code>{= int | null =}</code> defines nullable integer type in TypeScript.</p>
</div>
<div class="lf-py">
<pre><code class="language-lf">reactor &#x3C;class-name>(&#x3C;param-name>(&#x3C;expr>), ... ) {
    ...
}
</code></pre>
</div>
<p>Each parameter must have a <em>default value</em>, written <code>(&#x3C;expr>)</code>. An expression may be a numeric contant, a string enclosed in quotation marks, a time value such as <code>10 msec</code>, a list of values, or target-language code enclosed in <code>{= ... =}</code>, for example. See <a href="https://www.typescriptlang.org/docs/handbook/expressions">Expressions</a> for full details on what expressions are valid.</p>
<p>For example, the <code>Double</code> reactor on the <a href="https://www.typescriptlang.org/docs/handbook/inputs-and-outputs">previous page</a> can be replaced with a more general parameterized reactor <code>Scale</code> as follows:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Scale(factor:int(2)) {
    input x:int;
    output y:int;
    reaction(x) -> y {=
        SET(y, x->value * self->factor);
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Scale.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Scale.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Scale.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Scale.lf
</code></pre>
<p></p>
<p>This reactor, given any input event <code>x</code> will produce an output <code>y</code> with value equal to the input scaled by the <code>factor</code> parameter. The default value of the <code>factor</code> parameter is 2, but this can be changed when the <code>Scale</code> reactor is instantiated.</p>
<p>Notice how, within the body of a reaction, the code accesses the parameter value. This is different for each target language. <span class="lf-c">In the C target, a <code>self</code> struct is provided that contains the parameter values.</span></p>
<h2>State Declaration</h2>
<p>A reactor declares a state variable as follows:</p>
<div class="lf-c lf-cpp lf-ts lf-rs">
<pre><code class="language-lf">    state &#x3C;name>:&#x3C;type>(&#x3C;value>);
</code></pre>
<p>The type can any of the same forms as for a parameter.</p>
</div>
<div class="lf-py">
<pre><code class="language-lf">    state &#x3C;name>(&#x3C;value>);
</code></pre>
</div>
<p>The <code>&#x3C;value></code> is an initial value and, like parameter values, can be given as an <a href="https://www.typescriptlang.org/docs/handbook/expressions">expression</a> or target language code with delimiters <code>{= ... =}</code>. The initial value can also be given as a parameter name. The value can be accessed and modified in a target-language-dependent way as illustrated by the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Count {
    state count:int(0);
    output y:int;
    timer t(0, 100 msec);
    reaction(t) -> y {=
        SET(y, self->count++);
    =}
}

</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Count.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Count.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Count.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Count.lf
</code></pre>
<p></p>
<p>This reactor has an integer state variable named <code>count</code>, and each time its reaction is invoked, it outputs the value of that state variable and increments it. The reaction is trigger by a <span class="lf_keywords">timer</span>, discussed in the next section.</p></div></div></article><h1 style='margin: 0 2rem' id='title-3'>Time and Timers</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<h2>Timers</h2>
<p>A key property of Lingua Franca is <strong>logical time</strong>. All events occur at an instant in logical time. By default, the runtime system does its best to align logical time with <strong>physical time</strong>, which is some measurement of time on the execution platform. The <strong>lag</strong> is defined to be physical time minus logical time, and the goal of the runtime system is maintain a small non-negative lag.</p>
<p>The <strong>lag</strong> is allowed to go negative only if the <a href="https://www.typescriptlang.org/docs/handbook/target-specification#fast"><code>fast</code> target property</a> or the <a href="https://www.typescriptlang.org/docs/handbook/target-specification#command-line-arguments">--fast</a> is set to <code>true</code>. In that case, the program will execute as fast as possible with no regard to physical time.</p>
<p>The simplest use of logical time in Lingua Franca is to invoke a reaction periodically. This is done by first declaring a <span class="lf_keywords">timer</span> using this syntax:</p>
<pre><code class="language-lf">    timer &#x3C;name>(&#x3C;offset>, &#x3C;period>);
</code></pre>
<p>The <code>&#x3C;period></code>, which is optional, specifies the time interval between timer events. The <code>&#x3C;offset></code>, which is also optional, specifies the (logical) time interval between when the program starts executing and the first timer event. If no period is given, then the timer event occurs only once. If neither an offset nor a period is specified, then one timer event occurs at program start, simultaneous with the <span class="lf_keywords">startup</span> event.</p>
<p>The period and offset are given by a number and a units, for example, <code>10 msec</code>. See the <a href="https://www.typescriptlang.org/docs/handbook/expressions#basic-expressions">expressions documentation</a> for allowable units. Consider the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
main reactor Timer {
    timer t(0, 1 sec);
    reaction(t) {=
        printf("Logical time is %lld.\n", get_logical_time());
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Timer.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Timer.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Timer.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Timer.lf
</code></pre>
<p></p>
<p>This specifies a timer named <code>t</code> that will first trigger at the start of execution and then repeatedly trigger at intervals of one second. Notice that the time units can be left off if the value is zero.</p>
<p>Each target provides a built-in function for retrieving the logical time at which the reaction is invoked,
<span class="lf-c"><code>get_logical_time()</code></span>
<span class="lf-cpp warning">FIXME</span>
<span class="lf-py warning">FIXME</span>
<span class="lf-ts warning">FIXME</span>
<span class="lf-rs warning">FIXME</span>.
On most platforms (with the exception of some embedded platforms), the returned value is a 64-bit number representing the number of nanoseconds that have elapsed since January 1, 1970. Executing the above displays something like the following:</p>
<pre><code>Logical time is 1648402121312985000.
Logical time is 1648402122312985000.
Logical time is 1648402123312985000.
...
</code></pre>
<p>The output lines appear at one second intervals unless the <code>fast</code> option has been specified.</p>
<h2>Elapsed Time</h2>
<p>The times above are a bit hard to read, so, for convenience, each target provides a built-in function to retrieve the <em>elapsed</em> time. For example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
main reactor TimeElapsed {
    timer t(0, 1 sec);
    reaction(t) {=
        printf(
            "Elapsed logical time is %lld.\n",
            get_elapsed_logical_time()
        );
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/TimeElapsed.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/TimeElapsed.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/TimeElapsed.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/TimeElapsed.lf
</code></pre>
<p></p>
<p>See the
<span class="lf-c"><a href="https://www.typescriptlang.org/docs/handbook/c-reactors#timed-behavior">C reactors documentation</a></span>
<span class="lf-cpp"><a href="https://www.typescriptlang.org/docs/handbook/cpp-reactors#timed-behavior">C++ reactors documentation</a></span>
<span class="lf-py"><a href="https://www.typescriptlang.org/docs/handbook/python-reactors#timed-behavior">Python reactors documentation</a></span>
<span class="lf-ts"><a href="https://www.typescriptlang.org/docs/handbook/ts-reactors#timed-behavior">TypeScript reactors documentation</a></span>
<span class="lf-rs"><a href="https://www.typescriptlang.org/docs/handbook/rust-reactors#timed-behavior">Rust reactors documentation</a></span>
for the full set of functions provided for accessing time values.</p>
<p>Executing this program will produce something like this:</p>
<pre><code>Elapsed logical time is 0.
Elapsed logical time is 1000000000.
Elapsed logical time is 2000000000.
...
</code></pre>
<h2>Comparing Logical and Physical Times</h2>
<p>The following program compares logical and physical times:</p>
<p></p>
<pre><code class="language-lf-c">target C;
main reactor TimeLag {
    timer t(0, 1 sec);
    reaction(t) {=
        interval_t t = get_elapsed_logical_time();
        interval_t T = get_elapsed_physical_time();
        printf(
            "Elapsed logical time: %lld, physical time: %lld, lag: %lld\n",
            t, T, T-t
        );
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/TimeLag.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/TimeLag.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/TimeLag.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/TimeLag.lf
</code></pre>
<p></p>
<p>Execution will show something like this:</p>
<pre><code>Elapsed logical time: 0, physical time: 855000, lag: 855000
Elapsed logical time: 1000000000, physical time: 1004714000, lag: 4714000
Elapsed logical time: 2000000000, physical time: 2004663000, lag: 4663000
Elapsed logical time: 3000000000, physical time: 3000210000, lag: 210000
...
</code></pre>
<p>In this case, the lag varies from a few hundred microseconds to a small number of milliseconds. The amount of lag will depend on the execution platform.</p>
<h2>Simultaneity and Instantaneity</h2>
<p>If two timers have the same <em>offset</em> and <em>period</em>, then their events are logically simultaneous. No observer will be able to see that one timer has triggered and the other has not.</p>
<p>A reaction is always invoked at a well-defined logical time, and logical time does not advance during its execution. Any output produced by the reaction will be <strong>logically simultaneous</strong> with the input. In other words, reactions are <strong>logically instantaneous</strong> (for an exception, see <a href="https://www.typescriptlang.org/docs/handbook/logical-execution-time">Logical Execution Time</a>). Physical time, however, does elapse during execution of a reaction.</p>
<h2>Timeout</h2>
<p>By default, a Lingua Franca program will terminate when there are no more events to process. If there is a timer with a non-zero period, then there will always be more events to process, so the default execution will be unbounded. To specify a finite execution horizon, you can either specify a <a href="https://www.typescriptlang.org/docs/handbook/target-specification#timeout"><code>timeout</code> target property</a> or a [<code>--timeout command-line option](ocs/handbook/target-specification#command-line-arguments). For example, the following </code>timeout` property will cause the above timer with a period of one second to terminate after 11 events:</p>
<pre><code class="language-lf-c">target C {
    timeout: 10 sec
}
</code></pre>
<pre><code class="language-lf-cpp">target Cpp {
    timeout: 10 sec
}
</code></pre>
<pre><code class="language-lf-py">target Python {
    timeout: 10 sec
}
</code></pre>
<pre><code class="language-lf-ts">target TypeScript {
    timeout: 10 sec
}
</code></pre>
<pre><code class="language-lf-rs">target Rust {
    timeout: 10 sec
}
</code></pre>
<h2>Startup and Shutdown</h2>
<p>To cause a reaction to be invoked at the start of execution, a special <strong>startup</strong> trigger is provided:</p>
<pre><code class="language-lf">reactor Foo {
    reaction(startup) {=
        ... perform initialization ...
    =}
}
</code></pre>
<p>The <strong>startup</strong> trigger is equivalent to a timer with no <em>offset</em> or <em>period</em>.</p>
<p>To cause a reaction to be invoked at the end of execution, a special <strong>shutdown</strong> trigger is provided. Consider the following reactor, commonly used to build regression tests:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor TestCount(start:int(0), stride:int(1), num_inputs:int(1)) {
    state count:int(start);
    state inputs_received:int(0);
    input x:int;
    reaction(x) {=
        printf("Received %d.\n", x->value);
        if (x->value != self->count) {
            printf("ERROR: Expected %d.\n", self->count);
            exit(1);
        }
        self->count += self->stride;
        self->inputs_received++;
    =}
    reaction(shutdown) {=
        printf("Shutdown invoked.\n");
        if (self->inputs_received != self->num_inputs) {
            printf("ERROR: Expected to receive %d inputs, but got %d.\n",
                self->num_inputs,
                self->inputs_received
            );
            exit(2);
        }
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/TestCount.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/TestCount.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/TestCount.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/TestCount.lf
</code></pre>
<p></p>
<p>This reactor tests its inputs against expected values, which are expected to start with the value given by the <code>start</code> parameter and increase by <code>stride</code> with each successive input. It expects to receive a total of <code>num_inputs</code> input events. It checks the total number of inputs received in its <span class="lf_keywords">shutdown</span> reaction.</p>
<p>The <strong>shutdown</strong> trigger typically occurs at <a href="https://www.typescriptlang.org/docs/handbook/actions#superdense-time">microstep</a> 0, but may occur at a larger microstep. See <a href="https://www.typescriptlang.org/docs/handbook/actions#superdense-time">Superdense Time</a> and <a href="https://www.typescriptlang.org/docs/handbook/termination">Termination</a>.</p></div></div></article><h1 style='margin: 0 2rem' id='title-4'>Composing Reactors</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<h2>Contained Reactors</h2>
<p>Reactors can contain instances of other reactors defined in the same file or in an imported file. Assume the <code>Count</code> and <code>Scale</code> reactors defined in <a href="https://www.typescriptlang.org/docs/handbook/parameters-and-state-variables">Parameters and State Variables</a> are stored in files <code>Count.lf</code> and <code>Scale.lf</code>, respectively,
and that the <code>TestCount</code> reactor from <a href="https://www.typescriptlang.org/docs/handbook/time-and-timers">Time and Timers</a> is stored in <code>TestCount.lf</code>. Then the following program composes one instance of each of the three:</p>
<p></p>
<pre><code class="language-lf-c">target C {
    timeout: 1 sec,
    fast: true
}
import Count from "Count.lf";
import Scale from "Scale.lf";
import TestCount from "TestCount.lf";

main reactor RegressionTest {
    c = new Count();
    s = new Scale(factor = 4);
    t = new TestCount(stride = 4, num_inputs = 11);
    c.y -> s.x;
    s.y -> t.x;
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/RegressionTest.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/RegressionTest.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/RegressionTest.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/RegressionTest.lf
</code></pre>
<p></p>
<h2>Diagrams</h2>
<p>As soon as programs consist of more than one reactor, it becomes particularly useful to reference the diagrams that are automatically created and displayed by the Lingua Franca IDEs. The diagram for the above program is as follows:</p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/RegressionTest.svg" width="500"/>
<p>In this diagram, the timer is represented by a clock-like icon, the reactions by chevron shapes, and the <span class="lf_keywords">shutdown</span> event by a diamond. If there were a <span class="lf_keywords">startup</span> event in this program, it would appear as a circle.</p>
<h2>Creating Reactor Instances</h2>
<p>An instance is created with the syntax:</p>
<pre><code class="language-lf">    &#x3C;instance_name> = new &#x3C;class_name>(&#x3C;parameters>)
</code></pre>
<p>A bank with several instances can be created in one such statement, as explained in the <a href="https://www.typescriptlang.org/docs/handbook/multiports-banks#banks-of-reactors">banks of reactors documentation</a>.</p>
<p>The <code>&#x3C;parameters></code> argument is a comma-separated list of assignments:</p>
<pre><code class="language-lf">    &#x3C;parameter_name> = &#x3C;value>, ...
</code></pre>
<p>Like the default value for parameters, <code>&#x3C;value></code> can be a numeric contant, a string enclosed in quotation marks, a time value such as <code>10 msec</code>, target-language code enclosed in <code>{= ... =}</code>, or any of the list forms described in <a href="https://www.typescriptlang.org/docs/handbook/expressions">Expressions</a>.</p>
<h2>Connections</h2>
<p>Connections between ports are specified with the syntax:</p>
<pre><code class="language-lf">    &#x3C;source_port_reference> -> &#x3C;destination_port_reference>
</code></pre>
<p>where the port references are either <code>&#x3C;instance_name>.&#x3C;port_name></code> or just <code>&#x3C;port_name></code>, where the latter form is used for connections that cross hierarchical boundaries, as illustrated in the next section.</p>
<p>On the left and right of a connection statement, you can put a comma-separated list. For example, the above pair of connections can be written,</p>
<pre><code class="language-lf">    c.y, s.y -> s.x, t.x
</code></pre>
<p>The only constraint is that the total number of channels on the left match the total number on the right.</p>
<p>A destination port (on the right) can only be connected to a single source port (on the left). However, a source port may be connected to multiple destinations, as in the following example:</p>
<pre><code class="language-lf">reactor A {
    output y:int
}
reactor B {
    input x:int
}
main reactor {
    a = new A()
    b1 = new B()
    b2 = new B()
    a.y -> b1.x
    a.y -> b2.x
}
</code></pre>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Multicast.svg" width="250"/>
<p>Lingua Franca provides a convenient shortcut for such multicast connections, where the above two lines can be replaced by one as follows:</p>
<pre><code class="language-lf">    (a.y)+ -> b1.x, b2.x
</code></pre>
<p>The enclosing <code>( ... )+</code> means to repeat the enclosed comma-separated list of sources however many times is needed to provide inputs to all the sinks on the right of the connection <code>-></code>.</p>
<h2>Import Statement</h2>
<p>An import statement has the form:</p>
<pre><code class="language-lf">    import &#x3C;reactor class> as &#x3C;alias2> from "&#x3C;path>"
</code></pre>
<p>where <code>&#x3C;reactor class></code> and <code>&#x3C;alias></code> can be a comma-separated list to import multiple reactors from the same file. The <code>&#x3C;path></code> specifies another <code>.lf</code> file relative to the location of the current file. The <code>as &#x3C;alias></code> portion is optional and specifies alternative class names to use in the <span class="lf_keywords">new</span> statements.</p>
<h2>Hierarchy</h2>
<p>Reactors can be composed in arbitrarily deep hierarchies. For example, the following program combines the <code>Count</code> and <code>Scale</code> reactors within on <code>Container</code>:</p>
<p></p>
<pre><code class="language-lf-c">target C;
import Count from "Count.lf";
import Scale from "Scale.lf";
import TestCount from "TestCount.lf";

reactor Container(stride:int(2)) {
    output y:int;
    c = new Count();
    s = new Scale(factor = stride);
    c.y -> s.x;
    s.y -> y;
}

main reactor Hierarchy {
    c = new Container(stride = 4);
    t = new TestCount(stride = 4, num_inputs = 11);
    c.y -> t.x;
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Hierarchy.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Hierarchy.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Hierarchy.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Hierarchy.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Hierarchy.svg" width="500"/>
<p>The <code>Container</code> has a parameter named <code>stride</code>, whose value is passed to the <code>factor</code> parameter of the <code>Scale</code> reactor. The line</p>
<pre><code class="language-lf">    s.y -> y;
</code></pre>
<p>establishes a connection across levels of the hierarchy. This propagates the output of a contained reactor to the output of the container. A similar notation may be used to propagate the input of a container to the input of a contained reactor,</p>
<pre><code class="language-lf">    x -> s.x;
</code></pre>
<h2>Connections with Logical Delays</h2>
<p>Connections may include a <strong>logical delay</strong> using the <span class="lf_keywords">after</span> keyword, as follows:</p>
<pre><code class="language-lf">    &#x3C;source_port_reference> -> &#x3C;destination_port_reference> after &#x3C;time_value>
</code></pre>
<p>where <code>&#x3C;time_value></code> can be any of the forms described in <a href="https://www.typescriptlang.org/docs/handbook/expressions">Expressions</a>.</p>
<p>The <span class="lf_keywords">after</span> keyword specifies that the logical time of the event delivered to the destination port will be larger than the logical time of the reaction that wrote to source port. The time value is required to be non-negative, but it can be zero, in which case the input event at the receiving end will be one <a href="https://www.typescriptlang.org/docs/handbook/actions#superdense-time">microstep</a> later than the event that triggered it.</p>
<h2>Physical Connections</h2>
<p>A subtle and rarely used variant of the <code>-></code> connection is a <strong>physical connection</strong>, denoted <code>~></code>. For example:</p>
<pre><code class="language-lf">main reactor {
    a = new A();
    b = new B();
    a.y ~> b.x;
}
</code></pre>
<p>This is rendered in by the diagram synthesizer as follows:</p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/PhysicalConnection.svg" width="200"/>
<p>In such a connection, the logical time at the recipient is derived from the local physical clock rather than being equal to the logical time at the sender. The physical time will always exceed the logical time of the sender (unless fast is set to <code>true</code>), so this type of connection incurs a nondeterministic positive logical time delay. Physical connections are useful sometimes in <a href="https://www.typescriptlang.org/docs/handbook/distributed-execution">Distributed-Execution</a> in situations where the nondeterministic logical delay is tolerable. Such connections are more efficient because timestamps need not be transmitted and messages do not need to flow through through a centralized coordinator (if a centralized coordinator is being used).</p></div></div></article><h1 style='margin: 0 2rem' id='title-5'>Reactions and Methods</h1><article><div class="whitespace raised"><div class="markdown"><h2>Reaction Order</h2>
<p>A reactor may have multiple reactions, and more than one reaction may be enabled at any given tag. In Lingua Franca semantics, if two or more reactions of the same reactor are <strong>simultaneously enabled</strong>, then they will be invoked sequentially in the order in which they are declared. More strongly, the reactions of a reactor are <strong>mutually exclusive</strong> and are invoked in tag order primarily and declaration order secondarily. Consider the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C {
    timeout: 3 secs
}
main reactor Alignment {
    state s:int(0);
    timer t1(100 msec, 100 msec);
    timer t2(200 msec, 200 msec);
    timer t4(400 msec, 400 msec);
    reaction(t1) {=
        self->s += 1;
    =}
    reaction(t2) {=
        self->s -= 2;
    =}
    reaction(t4) {=
        printf("s = %d\n", self->s);
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Alignment.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Alignment.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Alignment.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Alignment.lf
</code></pre>
<p></p>
<p>Every 100 ms, this increments the state variable <code>s</code> by 1, every 200 ms, it decrements <code>s</code> by 2, and every 400 ms, it prints the value of <code>s</code>. When these reactions align, they are invoked in declaration order, and, as a result, the printed value of <code>s</code> is always 0.</p>
<h2>Overwriting Outputs</h2>
<p>Just as the reactions of the <code>Alignment</code> reactor overwrite the state variable <code>s</code>, logically simultaneous reactions can overwrite outputs. Consider the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Overwriting {
    output y:int;
    state s:int(0);
    timer t1(100 msec, 100 msec);
    timer t2(200 msec, 200 msec);
    reaction(t1) -> y {=
        self->s += 1;
        SET(y, self->s);
    =}
    reaction(t2) -> y {=
        self->s -= 2;
        SET(y, self->s);
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Overwriting.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Overwriting.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Overwriting.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Overwriting.lf
</code></pre>
<p></p>
<p>Here, the reaction to <code>t1</code> will set the output to 1 or 2, but every time it sets it to 2, the second reaction (to <code>t2</code>) will overwrite the output with the value 0. As a consequence, the outputs will be 1, 0, 1, 0, ... deterministically.</p>
<h2>Reacting to Outputs of Contained Reactors</h2>
<p>A reaction may be triggered by the an input to the reactor, but also by an output of a contained reactor, as illustrated in the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
import Overwriting from "Overwriting.lf";
main reactor {
    s = new Overwriting();
    reaction(s.y) {=
        if (s.y->value != 0 &#x26;&#x26; s.y->value != 1) {
            error_print_and_exit("Outputs should only be 0 or 1!");
        }
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Contained.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Contained.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Contained.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Contained.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Contained.svg" width="300"/>
<p>This instantiates the above <code>Overwriting</code> reactor and monitors its outputs.</p>
<h2>Method Declaration</h2>
<div class="lf-c lf-py lf-ts lf-rs">
<p>The <span class="lf-c">C</span><span class="lf-cpp">Cpp</span><span class="lf-py">Python</span><span class="lf-ts">TypeScript</span><span class="lf-rs">Rust</span> target does not currently support methods.</p>
</div>
<div class="lf-cpp">
<p>A method declaration has one of the forms:</p>
<pre><code class="language-lf">  method &#x3C;name>();
  method &#x3C;name>():&#x3C;type>;
  method &#x3C;name>(&#x3C;argument_name>:&#x3C;type>, ...);
  method &#x3C;name>(&#x3C;argument_name>:&#x3C;type>, ...):&#x3C;type>;
</code></pre>
<p>The first form defines a method with no arguments and no return value. The second form defines a method with the return type <code>&#x3C;type></code> but no arguments. The third form defines a method with a comma-separated list of arguments given by their name and type, but without a return value. Finally, the fourth form is similar to the third, but adds a return type.</p>
<p>The <span class="lf_keywords">method</span> keywork can optionally be prefixed with the <span class="lf_keywords">const</span> qualifier, which indicates that the method is read only.</p>
<p>Methods are particularly useful in reactors that need to perform certain operations on state variables and/or parameters that are shared between reactions or that are too complex to be implemented in a single reaction. Analogous to class methods, methods in LF can access all state variables and parameters, and can be invoked from all reaction bodies or from other methods. Consider the following example:</p>
<p></p>
<pre><code class="language-lf-c">WARNING: No source file found: ../code/c/src/Methods.lf
</code></pre>
<pre><code class="language-lf-cpp">target Cpp;
main reactor Methods {
    state foo:int(2);
    const method getFoo(): int {=
        return foo;
    =}
    method add(x:int) {=
        foo += x;
    =}
    reaction(startup){=
        std::cout &#x3C;&#x3C; "Foo is initialized to " &#x3C;&#x3C; getFoo() &#x3C;&#x3C; '\n';
        add(40);
        std::cout &#x3C;&#x3C; "2 + 40 = " &#x3C;&#x3C; getFoo() &#x3C;&#x3C; '\n';
    =}
}

</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Methods.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Methods.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Methods.lf
</code></pre>
<p></p>
<p>This reactor defines two methods <code>getFoo</code> and <code>add</code>. <code>getFoo</code> is qualified as a const method, which indicates that it has read-only access to the state variables. This is direclty translated to a C++ const method in the code generation process. The <code>getFoo</code> method receives no arguments and returns an integer (<code>int</code>) indicating the current value of the <code>foo</code> state variable. The <code>add</code> method returns nothing (<code>void</code>) and receives one interger argument, which it uses to increment <code>foo</code>. Both methods are visible in all reactions of the reactor. In this example, the reaction to startup calls both methods in order to read and modify its state.</p>
</div></div></div></article><h1 style='margin: 0 2rem' id='title-6'>Causality Loops</h1><article><div class="whitespace raised"><div class="markdown"><h2>Cycles</h2>
<p>The interconnection pattern for a collection of reactors can form a cycle, but some care is required. Consider the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor A {
    input x:int;
    output y:int;
    reaction(x) -> y {=
        // ... something here ...
    =}
}
reactor B {
    input x:int;
    output y:int;
    reaction(x) {=
        // ... something here ...
    =}
    reaction(startup) -> y {=
        // ... something here ...
    =}
}
main reactor {
    a = new A();
    b = new B();
    a.y -> b.x;
    b.y -> a.x;
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Cycle.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Cycle.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Cycle.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Cycle.lf
</code></pre>
<p></p>
<p>This program yields the following diagram:</p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Cycle.svg" width="400"/>
<p>The diagram highlights a <strong>causality loop</strong> in the program. At each tag, in reactor <code>B</code>, the first reaction has to execute before the second if it is enabled, a precedence indicated with the red dashed arrow. But the first can't execute until the reaction of <code>A</code> has executed, and that reaction cannot execute until the second reaction <code>B</code> has executed. There is no way to satisfy these requirements, so the tools refuse to generated code.</p>
<h2>Cycles with Delays</h2>
<p>One way to break the causality loop and get an executable program is to introduce a <a href="https://www.typescriptlang.org/docs/handbook/composing-reactors#connections-with-logical-delays">logical delay</a> into the loop, as shown below:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor A {
    input x:int;
    output y:int;
    reaction(x) -> y {=
        // ... something here ...
    =}
}
reactor B {
    input x:int;
    output y:int;
    reaction(x) {=
        // ... something here ...
    =}
    reaction(startup) -> y {=
        // ... something here ...
    =}
}
main reactor {
    a = new A();
    b = new B();
    a.y -> b.x after 0;
    b.y -> a.x;
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/CycleWithDelay.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/CycleWithDelay.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/CycleWithDelay.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/CycleWithDelay.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/CycleWithDelay.svg" width="400"/>
<p>Here, we have used a delay of 0, which results in a delay of one <a href="https://www.typescriptlang.org/docs/handbook/superdense-time">microstep</a>. We could equally well have specified a positive time value.</p>
<h2>Reaction Order</h2>
<p>Frequently, a program will have such cycles, but you don't want a logical delay in the loop. To get a cycle without logical delays, the reactions need to be reordered, as shown below:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor A {
    input x:int;
    output y:int;
    reaction(x) -> y {=
        // ... something here ...
    =}
}
reactor B {
    input x:int;
    output y:int;
    reaction(startup) -> y {=
        // ... something here ...
    =}
    reaction(x) {=
        // ... something here ...
    =}
}
main reactor {
    a = new A();
    b = new B();
    a.y -> b.x;
    b.y -> a.x;
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/CycleReordered.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/CycleReordered.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/CycleReordered.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/CycleReordered.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/CycleReordered.svg" width="400"/>
<p>There is no longer any causality loop.</p></div></div></article><h1 style='margin: 0 2rem' id='title-7'>Extending Reactors</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<h2>Extending a Base Reactor</h2>
<p>Lingua Franca supports defining a reactor class as an extension (or subclass), as in the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor A {
    input a:int;
    output out:int;
    reaction(a) -> out {=
        SET(out, a->value);
    =}
}
reactor B extends A {
    input b:int;
    reaction(a, b) -> out {=
        SET(out, a->value + b->value);
    =}
}

</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Extends.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Extends.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Extends.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Extends.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Extends.svg" width="350"/>
<p>Here, the base class <code>A</code> has a single output that it writes to in reaction to an input. The subclass inherits the input, the output, and the reaction of <code>A</code>, and adds its own input <code>b</code> and reaction. When an input event <code>a</code> arrives, both reactions will be invoked, but, once again, in a well-defined order. The reactions of the base class are invoked before those of the derived class. So in this case, <code>B</code> will overwrite the output produced by <code>A</code>.</p>
<p>One limitation is that a subclass cannot have ports, actions, or state variables with the same names as those in the base class. The names must be unique.</p>
<p>A subclass can extend more than one base class by just providing a comma-separated list of base classes. If reactions in multiple base classes are triggered at the same tag, they will be invoked in the same order that they appear in the comma-separated list.</p></div></div></article><h1 style='margin: 0 2rem' id='title-8'>Actions</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<h2>Action Declaration</h2>
<p>An action declaration has one of the following forms:</p>
<pre><code class="language-lf">    logical action &#x3C;name>(&#x3C;min_delay>, &#x3C;min_spacing>, &#x3C;policy>)
    physical action &#x3C;name>(&#x3C;min_delay>, &#x3C;min_spacing>, &#x3C;policy>)
</code></pre>
<p>The <code>min_delay</code>, <code>min_spacing</code>, and <code>policy</code> are all optional. If only one argument is given in parentheses, then it is interpreted as an <code>min_delay</code>, if two are given, then they are interpreted as <code>min_delay</code> and <code>min_spacing</code>. The <code>min_delay</code> and <code>min_spacing</code> are time values. The <code>policy</code> argument is a string that can be one of the following: <code>"defer"</code> (the default), <code>"drop"</code>, or <code>"replace"</code>. Note that the quotation marks are needed.</p>
<div class="lf-c lf-cpp lf-ts lf-rs">
<p>If the action is to carry a payload, then a type must be given as well:</p>
<pre><code class="language-lf">    logical action &#x3C;name>(&#x3C;min_delay>, &#x3C;min_spacing>, &#x3C;policy>):&#x3C;type>
    physical action &#x3C;name>(&#x3C;min_delay>, &#x3C;min_spacing>, &#x3C;policy>):&#x3C;type>
</code></pre>
</div>
<h2>Logical Actions</h2>
<p>Timers are useful to trigger reactions once or periodically. Actions are used to trigger reactions more irregularly. An action, like an output or input port, can carry data, but unlike a port, an action is visible only within the reactor that defines it.</p>
<p>There are two kinds of actions, <strong>logical</strong> and <strong>physical</strong>. A <span class="lf_keywords">logical</span> <span class="lf_keywords">action</span> is used by a reactor to schedule a trigger at a fixed logical time interval <em>d</em> into the future. The time interval <em>d</em>, which is called a <strong>delay</strong>, is relative to the logical time <em>t</em> at which the scheduling occurs. If a reaction executes at logical time <em>t</em> and schedules an action <code>a</code> with delay <em>d</em>, then any reaction that is triggered by <code>a</code> will be invoked at logical time <em>t</em> + <em>d</em>. For example, the following reaction schedules something (printing the current elapsed logical time) 200 msec after an input <code>x</code> arrives:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Schedule {
    input x:int;
    logical action a;
    reaction(x) -> a {=
        schedule(a, MSEC(200));
    =}
    reaction(a) {=
        interval_t elapsed_time = get_elapsed_logical_time();
        printf("Action triggered at logical time %lld nsec after start.\n", elapsed_time);
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Schedule.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Schedule.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Schedule.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Schedule.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Schedule.svg" width="200"/>
<p>Here, the delay is specified in the call to <code>schedule()</code> within the target language code. Notice that in the diagram, a logical action is shown as a triangle with an <strong>L</strong>. Logical actions are always scheduled within a reaction of the reactor that declares the action.</p>
<p>The arguments to the <code>schedule()</code> function are the action named <code>a</code> and a time. The action <code>a</code> has to be declared as an effect of the reaction in order to reference it in the call to <code>schedule()</code>. If you fail to declare it as an effect (after the <code>-></code> in the reaction signature), then you will get an error message.</p>
<div class="lf-c">
<p>The time argument to the <code>schedule()</code> function has data type <code>interval_t</code>, which, with the exception of some embedded platforms, is a C <code>long long</code>. A collection of convenience macros is provided like the <code>MSEC</code> macro above to specify time values in a more readable way. The provided macros are <code>NSEC</code>, <code>USEC</code> (for microseconds), <code>MSEC</code>, <code>SEC</code>, <code>MINUTE</code>, <code>HOUR</code>, <code>DAY</code>, and <code>WEEK</code>. You may also use the plural of any of these, e.g. <code>WEEKS(2)</code>.</p>
<p>The time argument to the <code>schedule()</code> function is required to be non-negative. If it is zero, then the action will be scheduled one <strong>microstep</strong> later. See <a href="#superdense-time">Superdense Time</a> below.</p>
<p>An action may have a data type, in which case, a variant of the <code>schedule()</code> function can be used to specify a <strong>payload</strong>, a data value that is carried from where the <code>schedule()</code> function is called to the reaction that is triggered by the action. See <a href="https://www.typescriptlang.org/docs/handbook/c-reactors#actions-with-values">Actions With Values</a> in the C Reactors documentation.</p>
</div>
<div class="lf-cpp">
<p><span class="warning">FIXME</span></p>
<p>The time argument to the <code>schedule()</code> function is required to be non-negative. If it is zero, then the action will be scheduled one <strong>microstep</strong> later. See <a href="#superdense-time">Superdense Time</a> below.</p>
<p>An action may have a data type, in which case, a variant of the <code>schedule()</code> function can be used to specify a <strong>payload</strong>, a data value that is carried from where the <code>schedule()</code> function is called to the reaction that is triggered by the action. See <a href="https://www.typescriptlang.org/docs/handbook/cpp-reactors#actions-with-values">Actions With Values</a> in the C++ Reactors documentation.</p>
</div>
<div class="lf-py">
<p><span class="warning">FIXME</span></p>
<p>The time argument to the <code>schedule()</code> function is required to be non-negative. If it is zero, then the action will be scheduled one <strong>microstep</strong> later. See <a href="#superdense-time">Superdense Time</a> below.</p>
<p>An action may have a data type, in which case, a variant of the <code>schedule()</code> function can be used to specify a <strong>payload</strong>, a data value that is carried from where the <code>schedule()</code> function is called to the reaction that is triggered by the action. See <a href="https://www.typescriptlang.org/docs/handbook/python-reactors#actions-with-values">Actions With Values</a> in the Python Reactors documentation.</p>
</div>
<div class="lf-ts">
<p><span class="warning">FIXME</span></p>
<p>The time argument to the <code>schedule()</code> function is required to be non-negative. If it is zero, then the action will be scheduled one <strong>microstep</strong> later. See <a href="#superdense-time">Superdense Time</a> below.</p>
<p>An action may have a data type, in which case, a variant of the <code>schedule()</code> function can be used to specify a <strong>payload</strong>, a data value that is carried from where the <code>schedule()</code> function is called to the reaction that is triggered by the action. See <a href="https://www.typescriptlang.org/docs/handbook/typescript-reactors#actions-with-values">Actions With Values</a> in the TypeScript Reactors documentation.</p>
</div>
<div class="lf-rs">
<p><span class="warning">FIXME</span></p>
<p>The time argument to the <code>schedule()</code> function is required to be non-negative. If it is zero, then the action will be scheduled one <strong>microstep</strong> later. See <a href="#superdense-time">Superdense Time</a> below.</p>
<p>An action may have a data type, in which case, a variant of the <code>schedule()</code> function can be used to specify a <strong>payload</strong>, a data value that is carried from where the <code>schedule()</code> function is called to the reaction that is triggered by the action. See <a href="https://www.typescriptlang.org/docs/handbook/rust-reactors#actions-with-values">Actions With Values</a> in the Rust Reactors documentation.</p>
</div>
<h2>Physical Actions</h2>
<p>A <span class="lf_keywords">physical</span> <span class="lf_keywords">action</span> is used to schedule reactions at logical times determined by the local physical clock. If a physical action with delay <em>d</em> is scheduled at <em>physical</em> time <em>T</em>, then the <em>logical time</em> assigned to the event is <em>T</em> + <em>d</em>. For example, the following reactor schedules the physical action <code>p</code> to trigger at a <strong>logical time</strong> equal to the <strong>physical time</strong> at which the input <code>x</code> arrives:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Physical {
    input x:int;
    physical action a;
    reaction(x) -> a {=
        schedule(a, 0);
    =}
    reaction(a) {=
        interval_t elapsed_time = get_elapsed_logical_time();
        printf("Action triggered at logical time %lld nsec after start.\n", elapsed_time);
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Physical.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Physical.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Physical.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Physical.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Physical.svg" width="200"/>
<p>If you drive this with a timer, using for example the following structure:</p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/PhysicalTest.svg" width="400"/>
<p>then running the program will yield an output something like this:</p>
<pre><code>Action triggered at logical time 201491000 nsec after start.
Action triggered at logical time 403685000 nsec after start.
Action triggered at logical time 603669000 nsec after start.
...
</code></pre>
<p>Here, logical time is lagging physical time by a few milliseconds. Note that, unless the <a href="https://www.typescriptlang.org/docs/handbook/target-specification#fast">fast option</a> is given, logical time <em>t</em> chases physical time <em>T</em>, so <em>t</em> &#x3C; <em>T</em>. Hence, the event being scheduled in the reaction to input <code>x</code> is assured of being in the future in logical time.</p>
<p>Whereas logical actions are required to be scheduled within a reaction of the reactor that declares the action, physical actions can be scheduled by code that is outside the Lingua Franca system. For example, some other thread or a callback function may call <code>schedule()</code>, passing it a physical action. For example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
main reactor {
	preamble {=
		// Schedule an event roughly every 200 msec.
		void* external(void* a) {
            while (true) {
    			lf_nanosleep(MSEC(200));
    			schedule(a, 0);
			}
		}
	=}
	state thread_id:lf_thread_t(0);
    physical action a(100 msec):int;

	reaction(startup) -> a {=
		// Start a thread to schedule physical actions.
		lf_thread_create(&#x26;self->thread_id, &#x26;external, a);
	=}

	reaction(a) {=
        interval_t elapsed_time = get_elapsed_logical_time();
        printf("Action triggered at logical time %lld nsec after start.\n", elapsed_time);
	=}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Asynchronous.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Asynchronous.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Asynchronous.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Asynchronous.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Asynchronous.svg" width="350"/>
<p>Physical actions are the mechanism for obtaining input from the outside world. Because they are assigned a logical time derived from the physical clock, their logical time can be interpreted as a measure of the time at which some external event occurred.</p>
<div class="lf-c">
<p>In the above example, at <span class="lf_keywords">startup</span>, the main reactor creates an external thread that schedules a physical action roughly every 200 msec. The thread uses a built-in function <code>lf_nanosleep()</code>, which abstracts platform-specific mechanisms for stalling the thread for a specified amount of time. The thread is created with a built-in function <code>lf_thread_create()</code>, which similarly abstracts platform-specific mechanisms for creating threads.</p>
<p>The code executed by the thread is defined in a <span class="lf_keywords">preamble</span> section. See <a href="https://www.typescriptlang.org/docs/handbook/preambles-and-methods">Preambles and Methods</a>.</p>
<p><strong>Important Note:</strong> Asynchronous calls to <code>schedule()</code> will not work if you set the <a href="https://www.typescriptlang.org/docs/handbook/target-specification#threading"><code>threading</code> target parameter</a> to <code>false</code>. You must use a threaded runtime for such asynchronous calls to work correctly.</p>
<div>
<h2>Triggering Time for Actions</h2>
<p>An action will trigger at a logical time that depends on the arguments given to the schedule function, the <code>&#x3C;min_delay></code>, <code>&#x3C;min_spacing></code>, and <code>&#x3C;policy></code> arguments in the action declaration, and whether the action is physical or logical.</p>
<p>For a <span class="lf_keywords">logical</span> action <code>a</code>, the tag assigned to the event resulting from a call to <code>schedule(a, &#x3C;offset>)</code> is computed as follows. First, let <em>t</em> be the <em>current logical time</em>. For a logical action, <em>t</em> is just the logical time at which the reaction calling <code>schedule()</code> is called. The <strong>preliminary time</strong> of the action is then just <em>t</em> + <code>&#x3C;min_delay></code> + <code>&#x3C;offset></code>. This preliminary time may be further modified, as explained below.</p>
<p>For a <strong>physical</strong> action, the preliminary time is similar, except that <em>t</em> is replaced by the current <em>physical</em> time <em>T</em> when <code>schedule()</code> is called.</p>
<p>If a <code>&#x3C;min_spacing></code> has been declared, then it gives a minimum logical time interval between the tags of two subsequently scheduled events. If the preliminary time is closer than <code>&#x3C;min_spacing></code> to the time of the previously scheduled event (if there is one), then <code>&#x3C;policy></code> determines how the minimum spacing constraint is enforced. The <code>&#x3C;policy></code> is one of the following:</p>
<ul>
<li><code>"defer"</code>: (<strong>the default</strong>) The event is added to the event queue with a tag that is equal to earliest time that satisfies the minimal spacing requirement. Assuming the time of the preceding event is <em>t_prev</em>, then the tag of the new event simply becomes <em>t_prev</em> + <code>&#x3C;min_spacing></code>.</li>
<li><code>"drop"</code>: The new event is dropped and <code>schedule()</code> returns without having modified the event queue.</li>
<li><code>"replace"</code>: The payload (if any) of the new event is assigned to the preceding event if it is still pending in the event queue; no new event is added to the event queue in this case. If the preceding event has already been pulled from the event queue, the default <code>"defer"</code> policy is applied.</li>
</ul>
<p>Note that while the <code>"defer"</code> policy is conservative in the sense that it does not discard events, it could potentially cause an unbounded growth of the event queue.</p></div></div></article><h1 style='margin: 0 2rem' id='title-9'>Superdense Time</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<h2>Tag vs. Time</h2>
<p>The model of time in Lingua Franca is a bit more sophisticated than we have hinted at. Specifically, a <strong>superdense</strong> model of time is used. In particular, instead of a <strong>timestamp</strong>, LF uses a <strong>tag</strong>, which consists of a <strong>logical time</strong> <em>t</em> and a <strong>microstep</strong> <em>m</em>.</p>
<p>A <a href="https://www.typescriptlang.org/docs/handbook/actions#logical-actions"><span class="lf_keywords">logical</span> <span class="lf_keywords">action</span></a> may have a <code>&#x3C;min_delay></code> of zero, and the <code>&#x3C;offset></code> argument to the <code>schedule()</code> function may be zero. In this case, the call to <code>schedule()</code> appears to be requesting that the action trigger at the <em>current logical time</em>. Here is where superdense time comes in. The action will indeed trigger at the current logical time, but one microstep later. Consider the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
main reactor {
    state count:int(1);
    logical action a;
    reaction(startup, a) {=
        printf("%d. Logical time is %lld. Microstep is %d.\n",
            self->count, get_logical_time(), get_microstep()
        );
        if (self->count++ &#x3C; 5) {
            schedule(a, 0);
        }
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Microsteps.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Microsteps.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Microsteps.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Microsteps.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Microsteps.svg" width="150"/>
<p>Executing this program will yield something like this:</p>
<pre><code>1. Logical time is 1649607749415269000. Microstep is 0.
2. Logical time is 1649607749415269000. Microstep is 1.
3. Logical time is 1649607749415269000. Microstep is 2.
4. Logical time is 1649607749415269000. Microstep is 3.
5. Logical time is 1649607749415269000. Microstep is 4.
</code></pre>
<p>Notice that the logical time is not advancing, but the microstep is (the logical time, in this case, gives the number of nanoseconds that have elapsed since January 1, 1970). The general rule is that <strong>every</strong> call to <code>schedule()</code> advances the tag by at least one microstep.</p>
<h2>Logical Simultaneity</h2>
<p>Two events are <strong>logically simultaneous</strong> only if <em>both</em> the logical time and the microstep are equal. The following example illustrates this:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Destination {
    input x:int;
    input y:int;
    reaction(x, y) {=
        printf("Time since start: %lld, microstep: %d\n",
            get_elapsed_logical_time(), get_microstep()
        );
        if (x->is_present) {
            printf("  x is present.\n");
        }
        if (y->is_present) {
            printf("  y is present.\n");
        }
    =}
}
main reactor {
    logical action repeat;
    d = new Destination();
    reaction(startup) -> d.x, repeat {=
        SET(d.x, 1);
        schedule(repeat, 0);
    =}
    reaction(repeat) -> d.y {=
        SET(d.y, 1);
    =}
}

</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Simultaneous.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Simultaneous.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Simultaneous.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Simultaneous.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Simultaneous.svg" width="400"/>
<p>The <code>Destination</code> reactor has two inputs, <code>x</code> and <code>y</code>, and it reports in a reaction to either input what is the logical time, the microstep, and which input is present. The main reactor reacts to <span class="lf_keywords">startup</span> by sending data to the <code>x</code> input of <code>Destination</code>. It then schedules a <code>repeat</code> action with an <code>&#x3C;offset></code> of zero. The <code>repeat</code> reaction is invoked <strong>strictly later</strong>, one <strong>microstep</strong> later. The output printed, therefore, will look like this:</p>
<pre><code>Time since start: 0, microstep: 0
  x is present.
Time since start: 0, microstep: 1
  y is present.
</code></pre>
<p>The time reported by <code>get_elapsed_logical_time()</code> has not advanced in the second reaction, but the fact that <code>x</code> is not present in the second reaction proves that the first reaction and the second are not logically simultaneous. The second occurs one microstep later.</p>
<h2>Alignment of Logical and Physical Times</h2>
<p>Recall that in Lingua Franca, logical time "chases" physical time, invoking reactions at a physical time close to their logical time. For that purpose, the microstep is ignored.</p></div></div></article><h1 style='margin: 0 2rem' id='title-10'>Deadlines</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<p>Lingua Franca includes a notion of a <strong>deadline</strong>, which is a constraint on the relation between logical time and physical time. Specifically, a program may specify that the invocation of a reaction must occur within some <em>physical</em> time interval of the <em>logical</em> time of the message. If a reaction is invoked at logical time 12 noon, for example, and the reaction has a deadline of one hour, then the reaction is required to be invoked before the physical-time clock of the execution platform reaches 1 PM. If the deadline is violated, then the specified deadline handler is invoked instead of the reaction. For example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Deadline {
    input x:int;
    output d:int; // Produced if the deadline is violated.
    reaction(x) -> d {=
        printf("Normal reaction.\n");
    =} deadline(10 msec) {=
        printf("Deadline violation detected.\n");
        SET(d, x->value);
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Deadline.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Deadline.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Deadline.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Deadline.lf
</code></pre>
<p></p>
<p>This reactor specifies a deadline of 10 milliseconds (this can be a parameter of the reactor). If the reaction to <code>x</code> is triggered later in physical time than 10 msec past the timestamp of <code>x</code>, then the second body of code is executed instead of the first. That second body of code has access to anything the first body of code has access to, including the input <code>x</code> and the output <code>d</code>. The output can be used to notify the rest of the system that a deadline violation occurred. This reactor can be tested as follows:</p>
<p></p>
<pre><code class="language-lf-c">target C;
import Deadline from "Deadline.lf";
main reactor {
    logical action a;
    d = new Deadline();
    reaction(startup) -> d.x, a {=
        SET(d.x, 0);
        schedule(a, 0);
    =}
    reaction(a) -> d.x {=
        SET(d.x, 0);
        lf_nanosleep(MSEC(20));
    =}
    reaction(d.d) {=
        printf("Deadline reactor produced an output.\n");
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/DeadlineTest.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/DeadlineTest.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/DeadlineTest.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/DeadlineTest.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/DeadlineTest.svg" width="500"/>
<p>Running this program will result in the following output:</p>
<pre><code>Normal reaction.
Deadline violation detected.
Deadline reactor produced an output.
</code></pre>
<p>The first reaction of the <code>Deadline</code> reactor does not violate the deadline, but the second does. Notice that the sleep in the <span class="lf_keywords">main</span> reactor occurs <em>after</em> setting the output, but because of the deterministic semantics of LF, this does not matter. The actual value of an output cannot be known until every reaction that sets that output <em>completes</em> its execution. Since this reaction takes at least 20 msec to complete, the deadline is assured of being violated.</p>
<p>Notice that the deadline is annotated in the diagram with a small clock symbol.</p></div></div></article><h1 style='margin: 0 2rem' id='title-11'>Multiports and Banks</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<p>Lingua Franca provides a compact syntax for ports that can send or receive over multiple channels and another syntax for multiple instances of a reactor class. These are respectively called <strong>multiports</strong> and <strong>banks of reactors</strong>.</p>
<h2>Multiports</h2>
<p>To declare an input or output port to be a <strong>multiport</strong>, use the following syntax:</p>
<div class="lf-c lf-cpp lf-rs">
<pre><code class="language-lf">    input[&#x3C;width>] &#x3C;name>:&#x3C;type>;
    output[&#x3C;width>] &#x3C;name>:&#x3C;type>;
</code></pre>
</div>
<div class="lf-ts lf-py">
<pre><code class="language-lf">    input[&#x3C;width>] &#x3C;name>
    output[&#x3C;width>] &#x3C;name>
</code></pre>
</div>
<p>where <code>&#x3C;width></code> is a positive integer. This can be given either as an integer literal or a parameter name. <span class="lf-cpp"> The width can also be given by target code enclosed in <code>{=...=}</code>.</span> Consider the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Source {
    output[4] out:int;
    reaction(startup) -> out {=
        for(int i = 0; i &#x3C; out_width; i++) {
            SET(out[i], i);
        }
    =}
}
reactor Destination {
    input[4] in:int;
    reaction(in) {=
        int sum = 0;
        for (int i = 0; i &#x3C; in_width; i++) {
            if (in[i]->is_present) sum += in[i]->value;
        }
        printf("Sum of received: %d.\n", sum);
    =}
}
main reactor {
    a = new Source();
    b = new Destination();
    a.out -> b.in;
}

</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Multiport.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Multiport.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Multiport.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Multiport.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Multiport.svg" width="300"/>
<p>Executing this program will yield:</p>
<pre><code>Sum of received: 6.
</code></pre>
<p>The <code>Source</code> reactor has a four-way multiport output and the <code>Destination</code> reactor has a four-way multiport input. These channels are connected all at once on one line, the second line from the last. Notice that the generated diagram shows multiports with hollow triangles. Whether it shows the widths is controlled by an option in the diagram generator.</p>
<p><strong>NOTE</strong>: In <code>Destination</code>, the reaction is triggered by <code>in</code>, not by some individual channel of the multiport input. Hence, it is important when using multiport inputs to test for presence of the input on each channel, as done above with the syntax <span class="lf-c"><code>if (in[i]->is_present) ...</code></span><span class="lf-cpp lf-py lf-ts lf-rs warning">FIXME</span>. An event on any one of the channels is sufficient to trigger the reaction.</p>
<p>The <code>Source</code> reactor also specifies <code>out</code> as an effect of its reaction using the syntax <code>-> out</code>. This brings into scope of the reaction body a way to access the width of the port and a way to write to each channel of the port.</p>
<div class="lf-py">
<p>In the Python target, multiports can be iterated on in a for loop (e.g., <code>for p in out</code>) or enumerated (e.g., <code>for i, p in enumerate(out)</code>) and the length of the multiport can be obtained by using the <code>len()</code> (e.g., <code>len(out)</code>) expression.</p>
</div>
<h2>Parameterized Widths</h2>
<p>The width of a port may be given by a parameter. For example, the above <code>Source</code> reactor can be rewritten</p>
<pre><code class="language-lf">reactor Source(width:int(4)) {
    output[width] out:int;
    reaction(startup) -> out {=
        ...
    =}
}

</code></pre>
<div class="lf-cpp">
<p>Parameters to the main reactor can be overwritten on the command line interface when running the generated program. As a consequence, the scale of the application can be determined at run time rather than at compile time.</p>
</div>
<h2>Connecting Reactors with Different Widths</h2>
<p>Assume that the <code>Source</code> and <code>Destination</code> reactors above both use a parameter <code>width</code> to specify the width of their ports. Then the following connection is valid:</p>
<pre><code class="language-lf">main reactor {
    a1 = new Source(width = 3);
    a2 = new Source(width = 2);
    b = new Destination(width = 5);
    a1.out, a2.out -> b.in;
}
</code></pre>
<p>The first three ports of <code>b</code> will received input from <code>a1</code>, and the last two ports will receive input from <code>a2</code>. Parallel composition can appear on either side of a connection. For example:</p>
<pre><code class="language-lf">    a1.out, a2.out -> b1.out, b2.out, b3.out;
</code></pre>
<p>If the total width on the left does not match the total width on the right, then a warning is issued. If the left side is wider than the right, then output data will be discarded. If the right side is wider than the left, then inputs channels will be absent.</p>
<p>Any given port can appear only once on the right side of the <code>-></code> connection operator, so all connections to a multiport destination must be made in one single connection statement.</p>
<h2>Banks of Reactors</h2>
<p>Using a similar notation, it is possible to create a bank of reactors. For example, we can create a bank of four instances of <code>Source</code> and four instances of <code>Destination</code> and connect them as follows:</p>
<pre><code class="language-lf">main reactor {
    a = new[4] Source();
    b = new[4] Destination();
    a.out -> b.in;
}
</code></pre>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/BankToBankMultiport.svg" width="300"/>
<p>If the <code>Source</code> and <code>Destination</code> reactors have multiport inputs and outputs, as in the examples above, then a warning will be issued if the total width on the left does not match the total width on the right. For example, the following is balanced:</p>
<pre><code class="language-lf">main reactor {
    a = new[3] Source(width = 4);
    b = new[4] Destination(width = 3);
    a.out -> b.in;
}
</code></pre>
<p>There will be three instances of <code>Source</code>, each with an output of width four, and four instances of <code>Destination</code>, each with an input of width 3, for a total of 12 connections.</p>
<p>To distinguish the instances in a bank of reactors, the reactor can define a parameter called <strong>bank_index</strong><span class="lf-c lf-cpp lf-rs"> with any type that can be assigned a non-negative integer value (for example, <code>int</code>, <code>size_t</code>, or <code>uint32_t</code>)</span>. If such a parameter is defined for the reactor, then when the reactor is instanced in a bank, each instance will be assigned a number between 0 and <em>n</em>-1, where <em>n</em> is the number of reactor instances in the bank. For example, the following source reactor increments the output it produces by the value of <code>bank_index</code> on each reaction to the timer:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor MultiportSource(
    bank_index:int(0)
) {
    timer t(0, 200 msec);
    output out:int;
    state s:int(0);
    reaction(t) -> out {=
        SET(out, self->s);
        self->s += self->bank_index;
    =}
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/MultiportSource.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/MultiportSource.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/MultiportSource.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/MultiportSource.lf
</code></pre>
<p></p>
<p>The width of a bank may also be given by a parameter, as in</p>
<pre><code class="language-lf">main reactor(
    source_bank_width:int(3),
    destination_bank_width:int(4)
) {
    a = new[source_bank_width] Source(width = 4);
    b = new[destination_bank_width] Destination(width = 3);
    a.out -> b.in;
}
</code></pre>
<h2>Contained Banks</h2>
<p>Banks of reactors can be nested. For example, note the following program:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Child (
    bank_index:int(0)
) {
    reaction(startup) {=
        printf("My bank index: %d.\n", self->bank_index);
    =}
}
reactor Parent (
    bank_index:int(0)
) {
    c = new[2] Child();
}
main reactor {
    p = new[2] Parent();
}

</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/ChildBank.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/ChildBank.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/ChildBank.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/ChildBank.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/ChildBank.svg" width="150"/>
<p>In this program, the <code>Parent</code> reactor contains a bank of <code>Child</code> reactor instances
with a width of 2. In the main reactor, a bank of <code>Parent</code> reactors is
instantiated with a width of 2, therefore, creating 4 <code>Child</code> instances in the program in total.
The output of this program will be:</p>
<pre><code>My bank index: 0.
My bank index: 1.
My bank index: 0.
My bank index: 1.
</code></pre>
<p>The order of these outputs will be nondeterministic if the execution is multithreaded (which it will be by default) because there is no dependence between the reactions, and, hence, they can execute in parallel.</p>
<p>The bank index of a container (parent) reactor can be passed down to
contained (child) reactors. For example, note the following program:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Child (
    bank_index:int(0),
    parent_bank_index:int(0)
) {
    reaction(startup) {=
        printf(
            "My bank index: %d. My parent's bank index: %d.\n",
            self->bank_index, self->parent_bank_index
        );
    =}
}
reactor Parent (
    bank_index:int(0)
) {
    c = new[2] Child(parent_bank_index = bank_index);
}
main reactor {
    p = new[2] Parent();
}
</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/ChildParentBank.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/ChildParentBank.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/ChildParentBank.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/ChildParentBank.lf
</code></pre>
<p></p>
<p>In this example, the bank index of the <code>Parent</code> reactor is passed to the
<code>parent_bank_index</code> parameter of the <code>Child</code> reactor instances.
The output from this program will be:</p>
<pre><code>My bank index: 1. My parent's bank index: 1.
My bank index: 0. My parent's bank index: 0.
My bank index: 0. My parent's bank index: 1.
My bank index: 1. My parent's bank index: 0.
</code></pre>
<p>Again, note that the order of these outputs is nondeterministic.</p>
<p>Finally, members of contained banks of reactors can be individually addressed in
the body of reactions of the parent reactor if their input/output port appears
in the reaction signature. For example, note the following program:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Child (
    bank_index:int(0),
    parent_bank_index:int(0)
) {
    output out:int;
    reaction(startup) -> out {=
        SET(out, self->parent_bank_index * 2 + self->bank_index);
    =}
}
reactor Parent (
    bank_index:int(0)
) {
    c = new[2] Child(parent_bank_index = bank_index);
    reaction(c.out) {=
        for (int i=0; i &#x3C; c_width; i++) {
            printf("Received %d from child %d.\n", c[i].out->value, i);
        }
    =}
}
main reactor {
    p = new[2] Parent();
}

</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/ChildParentBank2.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/ChildParentBank2.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/ChildParentBank2.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/ChildParentBank2.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/ChildParentBank2.svg" width="250"/>
<p>Running this program will give something like the following:</p>
<pre><code>Received 0 from child 0.
Received 1 from child 1.
Received 2 from child 0.
Received 3 from child 1.
</code></pre>
<div class="lf-c">
<p>Note the usage of <code>c_width</code>, which holds the width of the <code>c</code> bank of reactors.</p>
</div>
<div class="lf-py">
<p>Note that <code>len(c)</code> can be used to get the width of the bank, and <code>for p in c</code> or <code>for (i, p) in enumerate(c)</code> can be used to iterate over the bank members.</p>
</div>
<div class="lf-cpp lf-ts lf-rs warning">
<p>FIXME: explain how bank width is used in target code.</p>
</div>
<h2>Combining Banks and Multiports</h2>
<p>Banks of reactors may be combined with multiports, as in the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Source {
    output[3] out:int;
    reaction(startup) -> out {=
        for(int i = 0; i &#x3C; out_width; i++) {
            SET(out[i], i);
        }
    =}
}
reactor Destination(
    bank_index:int(0)
) {
    input in:int;
    reaction(in) {=
        printf("Destination %d received %d.\n", self->bank_index, in->value);
    =}
}

main reactor MultiportToBank {
    a = new Source();
    b = new[3] Destination();
    a.out -> b.in;
}

</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/MultiportToBank.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/MultiportToBank.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/MultiportToBank.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/MultiportToBank.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/MultiportToBank.svg" width="300"/>
<p>The three outputs from the <code>Source</code> instance <code>a</code> will be sent, respectively, to each of three instances of <code>Destination</code>, <code>b[0]</code>, <code>b[1]</code>, and <code>b[2]</code>. The result of the program will be something like the following:</p>
<pre><code>Destination 0 received 0.
Destination 1 received 1.
Destination 2 received 2.
</code></pre>
<p>Again, the order is nondeterministic in a multithreaded context.</p>
<p>The reactors in a bank may themselves have multiports. In all cases, the number of ports on the left of a connection must match the number on the right, unless the ones on the left are iterated, as explained next.</p>
<h2>Broadcast Connections</h2>
<p>Occasionally, you will want to have fewer ports on the left of a connection and have their outputs used repeatedly to broadcast to the ports on the right. In the following example, the outputs from an ordinary port are broadcast to the inputs of all instances of a bank of reactors:</p>
<pre><code class="language-lf">reactor Source {
	output out:int;
	reaction(startup) -> out {=
		... write to out ...
	=}
}
reactor Destination {
	input in:int;
	reaction(in) {=
		... read from in ...
	=}
}
main reactor ThreadedThreaded(width:int(4)) {
	a = new Source();
	d = new[width] Destination();
	(a.out)+ -> d.in;
}
</code></pre>
<p>The syntax <code>(a.out)+</code> means "repeat the output port <code>a.out</code> one or more times as needed to supply all the input ports of <code>d.in</code>." The content inside the parentheses can be a comma-separated list of ports, the ports inside can be ordinary ports or multiports, and the reactors inside can be ordinary reactors or banks of reactors. In all cases, the number of ports inside the parentheses on the left must divide the number of ports on the right.</p>
<h2>Interleaved Connections</h2>
<p>Sometimes, we don't want to broadcast messages to all reactors, but need more fine-grained control as to which reactor within a bank receives a message. If we have separate source and destination reactors, this can be done by combining multiports and banks as was shown in <a href="#Combining-Banks-and-Multiports">Combining Banks and Multiports</a>. Setting a value on the index <em>n</em> of the output multiport, will result in a message to the <em>n</em>-th reactor instance within the destianation bank. However, this pattern gets slightly more complicated, if we want to exchange addressable messages between instances of the same bank. This pattern is shown in the following example:</p>
<p></p>
<pre><code class="language-lf-c">target C;
reactor Node(
    num_nodes: size_t(4),
    bank_index: int(0)
) {
    input[num_nodes] in: int;
    output[num_nodes] out: int;

    reaction (startup) -> out {=
        SET(out[1], 42);
        printf("Bank index %d sent 42 on channel 1.\n", self->bank_index);
    =}

    reaction (in) {=
        for (int i = 0; i &#x3C; in_width; i++) {
            if (in[i]->is_present) {
                printf("Bank index %d received %d on channel %d.\n",
                    self->bank_index, in[i]->value, i
                );
            }
        }
    =}
}
main reactor(num_nodes: size_t(4)) {
    nodes = new[num_nodes] Node(num_nodes=num_nodes);
    nodes.out -> interleaved(nodes.in);
}

</code></pre>
<pre><code class="language-lf-cpp">WARNING: No source file found: ../code/cpp/src/Interleaved.lf
</code></pre>
<pre><code class="language-lf-py">WARNING: No source file found: ../code/py/src/Interleaved.lf
</code></pre>
<pre><code class="language-lf-ts">WARNING: No source file found: ../code/ts/src/Interleaved.lf
</code></pre>
<pre><code class="language-lf-rs">WARNING: No source file found: ../code/rs/src/Interleaved.lf
</code></pre>
<p></p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/Interleaved.svg" width="250"/>
<p>In the above program, four instance of <code>Node</code> are created, and, at startup, each instance sends 42 to its second (index 1) output channel. The result is that the second bank member (<code>bank_index</code> 1) will receive the number 42 on each input channel of its multiport input. Running this program gives something like the following:</p>
<pre><code>Bank index 0 sent 42 on channel 1.
Bank index 1 sent 42 on channel 1.
Bank index 2 sent 42 on channel 1.
Bank index 3 sent 42 on channel 1.
Bank index 1 received 42 on channel 0.
Bank index 1 received 42 on channel 1.
Bank index 1 received 42 on channel 2.
Bank index 1 received 42 on channel 3.
</code></pre>
<p>In bank index 1, the 0-th channel receives from <code>bank_index</code> 0, the 1-th channel from <code>bank_index</code> 1, etc. In effect, the choice of output channel specifies the destination reactor in the bank, and the input channel specifies the source reactor from which the input comes.</p>
<p>This style of connection is accomplished using the new keyword <span class="lf_keywords">interleaved</span> in the connection. Normally, a port reference such as <code>nodes.out</code> where <code>nodes</code> is a bank and <code>out</code> is a multiport, would list all the individual ports by first iterating over the banks and then, for each bank index, iterating over the ports. If we consider the tuple (b,p) to denote the index b within the bank and the index p within the multiport, then the following list is created: (0,0), (0,1), (0,2), (0,3), (1,0), (1,1), (1,2), (1,3), (2,0), (2,1), (2,2), (2,3), (3,0), (3,1), (3,2), (3,3). However, if we use <span class="lf_keywords">interleaved</span><code>(nodes.out)</code> instead, the connection logic will iterate over the ports first and then the banks, creating the following list: (0,0), (1,0), (2,0), (3,0), (0,1), (1,1), (2,1), (3,1), (0,2), (1,2), (2,2), (3,2), (0,3), (1,3), (2,3), (3,3). By combining a normal port reference with a interleaved reference, we can construct a fully connected network. The figure below visualizes this how this pattern would look without banks or multiports:</p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/AddressableDesugared.png" width="600"/>
<p>If we were to use a normal connection <code>nodes.out -> nodes.in;</code> instead of the <span class="lf_keywords">interleaved</span> connection, then the following pattern would be created:</p>
<img alt="Lingua Franca diagram" src="../../../../../img/diagrams/AddressableNaiveDesugared.png" width="600"/>
<p>Effectively, this connects each reactor instance to itself, which isn't very useful.</p></div></div></article><h1 style='margin: 0 2rem' id='title-12'>Preambles and Methods</h1><article><div class="whitespace raised"><div class="markdown"><p>
This page is showing examples in the target language 
  <span class="lf-c">C</span>
  <span class="lf-cpp">C++</span>
  <span class="lf-py">Python</span>
  <span class="lf-ts">TypeScript</span>
  <span class="lf-rs">Rust</span>.
You can change the target language in left sidebar.</p>
<h2>Preamble</h2>
<p>Reactions may contain arbitrary target-language code, but often it is convenient for that code to invoke external libraries or to share procedure definitions. For either purpose, a reactor may include a <span class="lf_keywords">preamble</span> section.</p>
<div class="lf-c">
<p>For example, the following reactor uses the common <code>stdlib</code> C library to convert a string to an integer:</p>
<pre><code class="language-lf-c">main reactor {
    preamble {=
        #include &#x3C;stdlib.h>
    =}
    timer t;
    reaction(t) {=
        char* s = "42";
        int i = atoi(s);
        printf("Converted string %s to int %d.\n", s, i);
    =}
}
</code></pre>
<p>This will print:</p>
<pre><code>Converted string 42 to int 42.
</code></pre>
<p>By putting the <code>#include</code> in the <span class="lf_keywords">preamble</span>, the library becomes available in all reactions of this reactor. Oddly, it also becomes available in all subsequently defined reactors in the same file or in files that include this file.</p>
<p>You can also use the <span class="lf_keywords">preamble</span> to define functions that are shared across reactions and reactors, as in this example:</p>
<pre><code class="language-lf-c">main reactor {
    preamble {=
        int add_42(int i) {
            return i + 42;
        }
    =}
    timer t;
    reaction(t) {=
        printf("42 plus 42 is %d.\n", add_42(42));
    =}
}
</code></pre>
<p>Not surprisingly, this will print:</p>
<pre><code>42 plus 42 is 84.
</code></pre>
<p>A <span class="lf_keywords">preamble</span> can also be put outside the <span class="lf_keywords">reactor</span> definition.
Currently, in the C target, it makes no difference whether it is put inside or outside.</p>
</div>
<div class="lf-cpp lf-py lf-ts lf-rs warning">
<p>FIXME</p>
</div>
<h2>Methods</h2>
<div class="lf-c lf-py lf-ts lf-rs">
<p>Methods are not currently implemented in the <span class="lf-c">C</span><span class="lf-cpp">Cpp</span><span class="lf-py">Python</span><span class="lf-ts">TypeScript</span><span class="lf-rs">Rust</span> target.</p>
</div>
<div class="lf-cpp warning">
<p>FIXME</p>
</div></div></div></article><h1 style='margin: 0 2rem' id='title-13'>Distributed Execution</h1><article><div class="whitespace raised"><div class="markdown"><pre><code class="language-diff">! The information in this page is outdated, and will be updated soon.
</code></pre>
<p><strong>NOTE:</strong> This describes a highly preliminary capability to map pieces of a Lingua Franca program to different machines. This capability is very much under development. This capability has been tested on MacOS and Linux, but not yet on Windows. Volunteer to do that and update these instructions?</p>
<p>A Lingua Franca program can be separated into separate programs called <strong>federates</strong> that communicate with one another. The federates will execute in separate processes and even on separate machines. They can be distributed across networks and can even be written in different target languages.</p>
<p>There is always one federate named <strong>RTI</strong>, for <strong>runtime infrastructure</strong> that coordinates startup and shutdown and may, if the implementation is centralized, mediate communication. The RTI needs to be compiled and installed separately on the system before any federation can execute. The instruction on how to do so can be found <a href="https://github.com/lf-lang/lingua-franca/blob/master/org.lflang/src/lib/core/federated/RTI/README.md">here</a>.</p>
<p>Other than the RTI, if there are <em>n</em> federates, then the code generator will generate <em>n</em> separate programs with names of the form <em>Name_Federate</em>, where <em>Name</em> is the name of the top-level Lingua Franca file (without the .lf extension) and <em>Federate</em> is the name of the federate reactor. The code generator also produces a shell script that lauches all the federates and the RTI and a second shell script that distributes the generated code for the federates (not the RTI) to the specified machines and compiles the code on that machine.</p>
<h2>Minimal Example</h2>
<p>A minimal federated execution is specified by using the <strong>federated</strong> keyword instead of <strong>main</strong> for the main federate. An example is given in <a href="https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorld.lf">example/C/Federated/HelloWorld/HelloWorld.lf</a>, which looks like this:</p>
<pre><code>target C;
reactor MessageGenerator { ... }
reactor PrintMessage { ... }

federated reactor DistributedHelloWorld {
    source = new MessageGenerator();
    print = new PrintMessage();
    source.message -> print.message;
}
</code></pre>
<p>The <strong>federated</strong> keyword tells the code generator that the program is to be split into several distinct programs, one for each top level reactor. When you run the code generator on <a href="https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorld.lf">example/C/Federated/HelloWorld/HelloWorld.lf</a>, the following three programs will appear in the <code>bin</code> directory:</p>
<ul>
<li>HelloWorld</li>
<li>HelloWorld_source</li>
<li>HelloWorld_print</li>
</ul>
<p>The root name, <em>HelloWorld</em>, is the name of the .lf file from which these are generated. The suffixes "_source" and "_print" come from the names of the top-level instances. There will always be one federate for each top-level reactor instance.</p>
<p>To run the program, you can simply run <code>bin/HelloWorld</code>, which is a <code>bash</code> script that launches the other three programs. Alternatively, you can manually execute the RTI and the federate programs by starting them on the command line in any order.</p>
<p>In addition, one more <code>bash</code> shell scripts may be generated:</p>
<ul>
<li>HelloWorld_distribute.sh</li>
</ul>
<p>This script is generated if any of the two federates, or the RTI are specified to be run on a remote machine (see below for how to do that). This script will copy the source files for the relevant program (but not the RTI) to the remote machine and compile them there. The RTI needs to be separately installed on the remote machine.</p>
<h2>Coordinated Start</h2>
<p>When the above programs execute, each federate registers with the RTI. When all expected federates have registered, the RTI broadcasts to the federates the logical time at which they should start execution. Hence, all federates start at the same logical time.</p>
<p>The starting logical time is determined as follows. When each federate starts executing, it sends its current physical time (drawn from its real-time clock) to the RTI. When the RTI has heard from all the federates, it chooses the largest of these physical times, adds a fixed offset (currently one second), and broadcasts the resulting time to each federate.</p>
<p>When a federate receives the starting time from the RTI, if it is running in realtime mode (the default), then it will wait until its local physical clock matches or exceeds that starting time. Thus, to the extent that the machines have <a href="#clock-synchronization">synchronized clocks</a>, the federates will all start executing at roughly the same physical time, a physical time close to the starting logical time.</p>
<h2>Coordinated Shutdown</h2>
<p>Coordinating the shutdown of a distributed program is discussed in [[Termination]].</p>
<h2>Communication Between Federates</h2>
<p>When one federate sends data to another, by default, the timestamp at the receiver will match the timestamp at the sender. You can also specify a logical delay on the communication using the <strong>after</strong> keyword. For example, if we had instead specified</p>
<pre><code>	source.out -> print.in after 200 msec;
</code></pre>
<p>then the timestamp at the receiving end will be incremented by 200 msec compared to the timestamp at the sender (see <a href="https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldAfter.lf">example/C/Federated/HelloWorld/HelloWorldAfter.lf</a>).</p>
<p>The preservation of timestamps across federates implies some constraints (see <a href="#physical-connections">physical connections</a> below for a way to avoid these constraints). How these constraints are managed depends on whether you choose <strong>centralized</strong> or <strong>decentralized</strong> coordination.</p>
<h2>Containerized Execution</h2>
<p>FIXME: Point to /docs/handbook/containerized-execution</p>
<p>FIXME: <a href="https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/docker/federated/DistributedCountContainerized.lf">Here</a> is an test that imports an <a href="https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/federated/DistributedCount.lf">existing</a> federated test with the addition of a docker: true flag in the target property of the test. This test will automatically run in multiple Docker containers (one for the RTI and one for each federate) in our CI.</p>
<h2>Centralized Coordination</h2>
<p>In the <strong>centralized</strong> mode of coordination (the default), the RTI regulates the advancement of time in each of the federates in order to ensure that the logical time semantics of Lingua Franca is respected. If the <code>print</code> federate has an event with timestamp <em>t</em> that it wants to react to (it is the earliest event in its event queue or it is a <strong>physical action</strong> that just triggered), then it needs to get the OK from the RTI to advance its logical time to <em>t</em>. The RTI grants this time advance only when it can assure that <code>print</code> has received all messages that it will ever receive with timestamps <em>t</em> or less.</p>
<p>First, note that, by default, logical time on each federate never advances ahead of physical time, as reported by its local physical clock. Consider the consequences for the above connection. Suppose the timestamp of the message sent by <code>source</code> is <em>t</em>. This message cannot be sent before the local clock at <code>source</code> reaches <em>t</em> and also cannot be sent before the RTI grants to <code>source</code> a time advance to <em>t</em>. Since <code>source</code> has no federates upstream of it, the RTI will always grant it such a time advance.</p>
<p>Suppose that the communication latency is <em>L</em>. That is, it takes <em>L</em> time units (in physical time) for a message to traverse the network. Then the <code>print</code> federate will not see the message from <code>source</code> before physical time <em>t</em> + <em>L</em>, where this physical time is measured by the physical clock on <code>source</code>'s host. If that clock differs from the clock on <code>print</code>'s host by <em>E</em>, then <code>print</code> will see the message at physical time <em>t</em> + <em>E</em> + <em>L</em>, as measured by its own clock. Let the value of the <strong>after</strong> specification (200 msec above) be <em>a</em>. Then the timestamp of the received message is <em>t</em> + <em>a</em>. The relationship between logical and physical times at the receiving end (the <code>print</code> federate), therefore, will depend on the relationship between <em>a</em> and <em>E</em> + <em>L</em>. If, for example, <em>E</em> + <em>L</em> > <em>a</em>, then federate <code>print</code> will lag behind physical time by at least <em>E</em> + <em>L</em> - <em>a</em>.</p>
<p>Assume the RTI has granted a time advance to <em>t</em> to federate <code>source</code>. Hence, <code>source</code> is able to send a message with timestamp <em>t</em>. The RTI now cannot grant any time advance to <code>print</code> that is greater than or equal to <em>t</em> + <em>a</em> until the message has been delivered to <code>print</code>. In centralized coordination, all messages flow through the RTI, so the RTI will deliver the time advance grant (<strong>TAG</strong>) to <code>print</code> only after it has delivered the message.</p>
<p>If <em>a</em> > <em>E</em> + <em>L</em>, then the existence of this communication does not cause <code>print</code>'s logical time to lag behind physical time. This means that if a <strong>physical action</strong> appears at <code>print</code>, the RTI will be able to immediately grant a time advance to <code>print</code> to the timestamp of that physical action. However, if <em>a</em> &#x3C; <em>E</em> + <em>L</em>, then the RTI will delay granting a time advance to <code>print</code> by at least <em>E</em> + <em>L</em> - <em>a</em>. Hence, <em>E</em> + <em>L</em> - <em>a</em> represents an additional latency in the processing of physical actions! This latency could present a problem for meeting deadlines. For this reason, if there are physical actions or deadlines at a federate that receives network messages, it is desirable to set <strong>after</strong> on the connection to that federate to be larger than any expected <em>E</em> + <em>L</em>. This way, there is no additional latency to processing physical actions at this federate and no additional risk of missing deadlines.</p>
<p>If, in addition, the physical clocks on the hosts are allowed to drift with respect to one another, then <em>E</em> can grow without bound, and hence the lag between logical time and physical time in processing events can grow without bound. This is mitigated either by hosts that themselves realize some clock synchronization algorithm, such as <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a> or <a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">PTP</a>, or by utilizing Lingua Franca's own built in <a href="#clock-synchronization">clock synchronization</a>. If the federates lack physical actions and deadlines, however, then unsynchronized clocks present no problem if you are using centralized coordination.</p>
<p>With centralized coordination, all messages (except those on <a href="#physical-connections">physical connections</a>) go through the RTI. This can create a bottleneck and a single point of failure. To avoid this bottleneck, you can use decentralized coordination.</p>
<h2>Decentralized Coordination</h2>
<p>The default coordination between mechanisms is <strong>centralized</strong>, equivalent to specifying the target property:</p>
<pre><code>   coordination: centralized
</code></pre>
<p>Centralized coordination works as described above, where the advancement of time at each federate is regulated by the RTI. In order for the RTI to be able to safely grant a time advance to a federate, it is also necessary for all messages to that federate to go through the RTI. The RTI, therefore, can easily become a bottleneck.</p>
<p>An alternative is <strong>decentralized</strong> coordination, which uses a technique called <a href="https://ptolemy.berkeley.edu/publications/papers/07/RTAS/">PTIDES</a>:</p>
<pre><code>   coordination: decentralized
</code></pre>
<p>This technique has also been implemented in Google Spanner, a globally distributed database system. In decentralized coordination, each federate has a <strong>safe-to-process</strong> (<strong>STP</strong>) offset. In decentralized coordination, when one federate communicates with another, it does so directly through a dedicated socket without going through the RTI. Moreover, it does not consult the RTI to advance logical time. Instead, it can advance its logical time to <em>t</em> when its physical clock matches or exceeds <em>t</em> + STP.</p>
<p>By default, the STP is zero. This will work fine under the assumption that <strong>every</strong> logical connection between federates has a sufficiently large <code>after</code> clause. That is, the value of the logical delay must exceed the sum of the <a href="#clock-synchronization">clock synchronization</a> error <em>E</em>, the network latency bound <em>L</em>, and the time lag on the sender <em>D</em> (the physical time at which it sends the message minus the timestamp of the message). The sender's time lag <em>D</em> can be enforced by using a <strong>deadline</strong>. See for example <a href="https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldDecentralized.lf">example/C/Federated/HelloWorld/HelloWorldDecentralized.lf</a>.</p>
<p>Of course, this assumption can be violated in practice. Analogous to a deadline violation, Lingua Franca provides a mechanism for handling such a violation that is called a <code>tardy</code> handlers as done in <a href="https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldDecentralized.lf">example/C/Federated/HelloWorld/HelloWorldDecentralized.lf</a>.(example/C/Federated/HelloWorld/HelloWorldDecentralized.lf). The pattern is:</p>
<pre><code>reaction(in) {=
    // User code
=} tardy {=
    // Error handling code
=}
</code></pre>
<p>If the timestamp at which this reaction is to be invoked (the value returned by <code>get_current_tag</code>) cannot match the timestamp of an incoming message <code>in</code> (because the current tag has already advanced beyond the intended tag of <code>in</code>), then the <code>tardy</code> handler will be invoked instead of the normal reaction. Within the body of the tardy handler, the code can access the intended tag of <code>in</code> using <code>in->intended_tag</code>, which has two fields, a timestamp <code>in->intended_tag.time</code> and a microstep <code>in->intended_tag.microstep</code>. The code can then ascertain the severity of the error and act accordingly. If no tardy handler is provided at any reaction triggered by an input from another federate, then the normal reaction will be invoked at the earliest feasible logical time greater than or equal to the intended logical time of the message.</p>
<p>One option available to the code is to increase the STP. This can be done simply by equipping a federate with a parameter of type <strong>time</strong> named <code>STP</code>. See for example <a href="https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldDecentralizedSTP.lf">example/C/Federated/HelloWorld/HelloWorldDecentralizedSTP.lf</a>. This can be done as follows:</p>
<pre><code>import PrintMessageWithDetector from "HelloWorldDecentralized.lf"
reactor PrintMessageWithSTP(STP:time(10 msec)) extends PrintMessageWithDetector {}
</code></pre>
<p>Notice that the only override in <code>PrintMessageWithSTP</code> is the addition of an <code>STP</code> parameter.</p>
<p>The LF API provides two functions that can be used to dynamically adjust the STP:</p>
<pre><code>interval_t get_stp_offset();
void set_stp_offset(interval_t offset);
</code></pre>
<p>Using these functions, however, is a pretty advanced operation.</p>
<p><strong>FIXME:</strong> The discussion of cycles in the remainder of this section needs to be revisited with pointers to newer examples.</p>
<p>Now suppose that if there are cycles in the communication between federates. For example, in addition to the above connection, suppose we also have a connection going in the opposite direction:</p>
<pre><code>	print.out -> count.in after 100 msec;
</code></pre>
<p>Now we potentially have a very big problem. The physical clock at <code>print</code> has to lag behind physical time by at least <em>E</em> + <em>L</em> - 200 msec, and the physical clock at <code>count</code> has to lag behind physical time by at least <em>E</em> + <em>L</em> - 100 msec. The latter of these means that <code>count</code> cannot send a message with timestamp <em>t</em> until its local clock exceeds <em>t</em> + <em>E</em> + <em>L</em> - 100 msec. If <em>E</em> + <em>L</em> - 100 msec > 0, then this additional lag increases the required lag at <code>print</code>, which will need to lag behind physical time now by <em>E</em> + <em>L</em> - 100 msec + <em>E</em> + <em>L</em> - 200 msec. If this number is positive, then the lag required at <code>count</code> will have to be again increased, which will then cause this number to again increase, and so on until the required lag is infinite at both federates. Thus, a cycle between two federates is <strong>infeasible</strong> if 2<em>E</em> + 2<em>L</em> - <em>a</em><sub>1</sub> - <em>a</em><sub>2</sub> > 0, where <em>a</em><sub>1</sub> and <em>a</em><sub>2</sub> are the <strong>after</strong> values of the two connections. More generally, the sum of <em>E</em> + <em>L</em> - <em>a</em><sub>i</sub> over all connections <em>i</em> in a cycle must be less than or equal to zero. Otherwise, decentralized coordination will fail and finite STP will lead to tardy messages. Centralized coordination can be used instead if the program really must be this way.</p>
<p>The bottom line is that if there are cycles in your federation and/or you have physical actions in federates that receive network messages, it is wise to specify <strong>after</strong> to be larger than the sum of the greatest expect clock synchronization error <em>E</em> and the greatest expected network latency <em>L</em>.</p>
<h2>Physical Connections</h2>
<p>Coordinating the execution of the federates so that timestamps are preserved is tricky. If your application does not require the deterministic execution that results from preserving the timestamps, then you can alternatively specify a <strong>physical connection</strong> as follows (see <a href="https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldPhysical.lf">example/C/Federated/HelloWorld/HelloWorldPhysical.lf</a>:</p>
<pre><code>source.out ~> print.in;
</code></pre>
<p>The tilde specifies that the timestamp of the sender should be discarded. A new timestamp will be assigned at the receiving end based on the local physical clock, much like a <strong>physical action</strong>. To distinguish it from a physical connection, the normal connection is called a <strong>logical connection</strong>.</p>
<p>There are a number of subtleties with physical connections. One is that if you specify an <code>after</code> clause, for example like this:</p>
<pre><code>count.out ~> print.in after 10 msec;
</code></pre>
<p>then what does this mean? At the receiving end, the timestamp assigned to the incoming event will be the current physical time plus 10 msec.</p>
<h2>Prerequisites for Distributed Execution</h2>
<p>In the above example, all of the generated programs expect to run on localhost. This is the default. With these defaults, every federate has to run on the same machine as the RTI because localhost is not a host that is visible from other machines on the network. In order to run federates or the RTI on remote machines, you can specify a domain name or IP address for the RTI and/or federates.</p>
<p>In order for a federated execution to work, there is some setup required on the machines to be used. First, each machine must be running on <code>ssh</code> server. On a Linux machine, this is typically done with a command like this:</p>
<pre><code>    sudo systemctl &#x3C;start|enable> ssh.service
</code></pre>
<p>Enable means to always start the service at startup, whereas start means to just start it this once. On MacOS, open System Preferences from the Apple menu and click on the "Sharing" preference panel. Select the checkbox next to "Remote Login" to enable it. <strong>FIXME</strong>: Windows?</p>
<p>It will also be much more convenient if the launcher does not have to enter passwords to gain access to the remote machine. This can be accomplished by installing your public key (typically found in <code>~/.ssh/id_rsa.pub</code>) in <code>~/.ssh/authorized_keys</code> on the remote host.</p>
<p>Second, the RTI must be installed on the remote machine. Instructions about installation of RTI can be found <a href="https://github.com/lf-lang/lingua-franca/blob/master/org.lflang/src/lib/core/federated/RTI/README.md">here</a>.</p>
<h2>Specifying RTI Hosts</h2>
<p>You can specify a domain name on which the RTI should run as follows:</p>
<pre><code>federated reactor DistributedCount at www.example.com {
    ...
}
</code></pre>
<p>You can alternatively specify an IP address (either IPv4 or IPv6):</p>
<pre><code>federated reactor DistributedCount at 10.0.0.198 { ... }
</code></pre>
<p>By default, the RTI starts a socket server on port 15045, if that port is available, and increments the port number by 1 until it finds an available port. The number of increments is limited by a target-specific number. In the C target, in rti.h, STARTING_PORT defines the number 15045 and PORT_RANGE_LIMIT limits the range of ports attempted (currently 1024).</p>
<p>You can also specify a port for the RTI to use as follows:</p>
<pre><code>federated reactor DistributedCount at 10.0.0.198:8080 { ... }
</code></pre>
<p>If you specify a specific port, then it will use that port if it is available and fail otherwise. The above changes this to port 8080.</p>
<p>You can also specify a user name on the remote machine for cases where the username will not match whoever launches the federation:</p>
<pre><code>federated reactor DistributedCount at user@10.0.0.198:8080 { ... }
</code></pre>
<p>The general form of the host designation is</p>
<pre><code>federated reactor DistributedCount at user@host:port/path { ... }
</code></pre>
<p>where <code>user@</code>, <code>:port</code>, and <code>/path</code> are all optional. The <code>path</code> specifies the directory on the remote machine (relative to the home directory of the user) where the generated code will be put. The <code>host</code> should be an IPv4 address (e.g. <code>93.184.216.34</code>), IPv6 address (e.g. <code>2606:2800:220:1:248:1893:25c8:1946</code>), or a domain name (e.g. <code>www.example.com</code>). It can also be <code>localhost</code> or <code>0.0.0.0</code>. The host can be remote as long as it is accessible from the machine where the programs will be started.</p>
<p>If <code>user@</code> is not given, then it is assumed that the username on the remote host is the same as on the machine that launches the programs. If <code>:port</code> is not given, then it defaults to port 15045. If <code>/path</code> is not given, then <code>~user/LinguaFrancaRemote</code> will be the root directory on the remote machine.</p>
<p><strong>FIXME</strong>: Not implemented yet: If the IP address or hostname does not match the local machine on which code generation is being done, ...</p>
<p>A <code>Federation_distribute.sh</code> shell script will be generated. This script will distribute the generated code for the RTI to the remote machine at the specified directory.</p>
<h2>Specifying Federate Hosts</h2>
<p>A federate may be mapped to a particular remote machine using a syntax like this:</p>
<pre><code>    count = new Count() at user@host:port/path;
</code></pre>
<p>The <code>port</code> is ignored in <strong>centralized</strong> mode because all communication is routed through the RTI, but in <strong>decentralized</strong> mode it will specify the port on which a socket server listens for incomming connections from other federates.</p>
<p>If any federate (or the RTI) has such a remote designator, then a <code>Federation_distribute.sh</code> shell script will be generated. This script will distribute the generated code for the RTI to the remote machine at the specified directory.</p>
<p>Note that if the machine uses DHCP to obtain its address, then the generated code may not work in the future since the address of the machine may change in the future.</p>
<p>Address 0.0.0.0: In the above example, <code>localhost</code> is used. This is the default if no address is specified. Using <code>localhost</code> specifies that the generated programs should establish connections only with processes running on the local machine. This is ideal for testing. If you use <code>0.0.0.0</code>, then you are also specifying that the local machine (the one performing the code generation) will be the host, but now the process(es) running on this local machine can establish connections with processes on remote machines. The code generator will determine the IP address of the local machine, and any other hosts that need to communicate with reactors on the local host will use the current IP address of that local host at the time of code generation.</p>
<h2>Clock Synchronization</h2>
<p>Both centralized and decentralized coordination have some reliance on clock synchronization. First, the RTI determines the start time of all federates, and the actually physical start time will differ by the extent that their physical clocks differ. This is particularly problematic if clocks differ by hours or more, which is certainly possible. If the hosts on which you are running run a clock synchronization algorithm, such as <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a> or <a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">PTP</a>, then you may not need to be concerned about this at all. Windows, Mac, and most versions of Linux, by default, run NTP, which synchronizes their clocks to some remote host. NTP is not particularly precise, however, so clock synchronization error can be hundreds of milliseconds or larger. PTP protocols are much more precise, so if your hosts derive their physical clocks from a PTP implementation, then you probably don't need to do anything further. Unfortunately, as of this writing, even though almost all networking hardware provides support for PTP, few operating systems utilize it. We expect this to change when people have finally understood the value of precise clock synchronization.</p>
<p>If your host is not running any clock synchronization, or if it is running only NTP and your application needs tighter latencies, then Lingua Franca's own built-in clock synchronization may provide better precision, depending on your network conditions. Like NTP, it realizes a software-only protocol, which are much less precise than hardware-supported protocols such as PTP, but if your hosts are on the same local area network, then network conditions may be such that the performance of LF clock synchronization will be much better than NTP. If your network is equipped with PTP, you will want to disable the clock synchronization in Lingua Franca by specifying in your target properties the following:</p>
<pre><code>    clock-sync: off
</code></pre>
<p>When a federation is mapped onto multiple machines, then, by default, any federate mapped to a machine that is not the one running the RTI will attempt during startup to synchronize its clock with the one on the machine running the RTI. The determination of whether the federate is running on the same machine is determined by comparing the string that comes after the <code>at</code> clause between the federate and the RTI. If they differ at all, then they will be treated as if the federate is running on a different machine even if it is actually running on the same machine. This default behavior can be obtained by either specifying nothing in the target properties or saying:</p>
<pre><code>    clock-sync: initial
</code></pre>
<p>This results in clock synchronization being done during startup only. To account for the possibility of your clocks drifting during execution of the program, you can alternatively specify:</p>
<pre><code>    clock-sync: on
</code></pre>
<p>With this specification, in addition to synchronization during startup, synchronization will be redone periodically during program execution.</p>
<h3>Clock Synchronization Options</h3>
<p>A number of options can be specified using the <code>clock-sync-options</code> target parameter. For example:</p>
<pre><code>    clock-sync-options: {local-federates-on: true, test-offset: 200 msec}
</code></pre>
<p>The supported options are:</p>
<ul>
<li>
<p><code>local-federates-on</code>: Should be <code>true</code> or <code>false</code>. By default, if a federate is mapped to the same host as the RTI (using the <code>at</code> keyword), then clock synchronization is turned off. This assumes that the federate will be using the same clock as the RTI, so there is no point in performing clock synchronization. However, sometimes it is useful to force clock synchronization to be run even in this case, for example to test the performance of clock synchronization. To force clock synchronization on in this case, set this option to <code>true</code>.</p>
</li>
<li>
<p><code>test-offset</code>: The value should be a time value with units, e.g. <code>200 msec</code>. This will establish an artificial fixed offset for each federate's clock of one plus the federate ID times the time value given. For example, with the value <code>200 msec</code>, a fixed offset of 200 milliseconds will be set on the clock for federate 0, 400 msec on the clock of federate 1, etc.</p>
</li>
<li>
<p><code>period</code>: A time value (with units) that specifies how often runtime clock synchronization will be performed if it is turned on. The default is <code>5 msec</code>.</p>
</li>
<li>
<p><code>attenuation</code>: A positive integer specifying a divisor applied to the estimated clock error during runtime clock synchronization when adjusting the clock offset. The default is <code>10</code>. Making this number bigger reduces each adjustment to the clock. Making the number equal to <code>1</code> means that each round of clock synchronization fully applies its estimated clock synchronization error.</p>
</li>
<li>
<p><code>trials</code>: The number of rounds of message exchange with the RTI in each clock synchronization round. This defaults to <code>10</code>.</p>
</li>
</ul>
<h2>Future Work</h2>
<p>The RTI can also play the role of <strong>auth</strong>, an authentication and authorization server that ensures that only the generated programs can establish connections with each other and that their communication is encrypted, as explained in the <a href="#Security">Security</a> section below.</p>
<p>Currently, the threads option is same on all federates. We need a mechanism to customize this parameter by federate.</p>
<h2>Security</h2>
<p>In addition to generating a program for each host, the code generator could generate configuration files for a program called <strong>auth</strong> designed to run on the first host that is preconfigured to provide authentication and authorization to each of the other generated programs together with encryption keys that are used for communicating between them. The auth program should be started first since non of the other generate programs will be able to authenticate without it.</p>
<p>The auth program, written by Hokeun Kim, comes from https://github.com/iotauth/iotauth and provides "locally centralized, globally distributed" authentication and authorization. Papers describing this work can be found here: [<a href="https://dl.acm.org/citation.cfm?id=3054980">IoTDI '17</a>], [<a href="http://ieeexplore.ieee.org/document/7575852/">FiCloud '16</a>] [<a href="https://ieeexplore.ieee.org/document/8057722/">IT Professional '17'</a>].</p>
<h2>Protobufs</h2>
<p>Communication between hosts can only be accomplished on channels where the message types are either language primitives or <a href="Protobufs">Protobufs</a>. All other datatypes will be reject at code generation time.</p></div></div></article><h1 style='margin: 0 2rem' id='title-14'>Termination</h1><article><div class="whitespace raised"><div class="markdown"><h2>Shutdown Reactions</h2>
<p>There are several mechanisms for terminating a Lingua Franca in an orderly fashion.
All of these mechanisms result in a <strong>final tag</strong> at which any reaction that declares <span class="lf_keywords">shutdown</span> as a trigger will be invoked (recall that a <strong>tag</strong> is a tuple (<strong>logical time</strong>, <strong>microstep</strong>)). Other reactions may also be invoked at this final tag, and the order in which reactions are invoked will be constrained by the normal precedence rules.</p>
<p>If a reaction triggered by <span class="lf_keywords">shutdown</span> produces outputs, then downstream reactors will also be invoked at the final tag. If the reaction schedules any actions by calling <code>schedule()</code>, those will be ignored. In fact, any event after the final tag will be ignored. After the completion of the final tag, the program will exit.</p>
<p>There are four ways to terminate a program:</p>
<ul>
<li><strong>Timeout</strong>: The program specifies the last logical time at which reactions should be triggered.</li>
<li><strong>Starvation</strong>: At the conclusion of some tag, there are no events in the event queue at future tags.</li>
<li><strong>Stop request</strong>: Some reaction requests that the program terminate.</li>
<li><strong>External signal</strong>: Program is terminated externally using operating services like control-C or <code>kill</code>.</li>
</ul>
<p>We address each of these in turn.</p>
<h2>Timeout</h2>
<p>The <a href="https://www.typescriptlang.org/docs/handbook/target-specification#timeout">target property <code>timeout</code></a> specifies the last logical time at which reactions should be triggered. The last invocation of reactions will be at tag (<code>timeout</code>, 0).</p>
<p>There is a significant subtlety when using <a href="https://www.typescriptlang.org/docs/handbook/composing-reactors#physical-connections">physical connections</a>, which are connections using the syntax <code>~></code>. Such connections specify that the tag at the receiving end will be based on the physical time at which the message is received. If the tag assigned at the receiving end is greater than the final tag, then the message is lost. Hence, <strong>messages sent near the <code>timeout</code> time are likely to be lost!</strong></p>
<h2>Starvation</h2>
<p>If a Lingua Franca program has no <a href="https://www.typescriptlang.org/docs/handbook/actions#physical-actions">physical actions</a>, and if at any time during execution there are no future events waiting to be processed, then there is no possibility for any more reactions to occur and the program will exit. This situation is called <strong>starvation</strong>. If there is a <strong>timer</strong> anywhere in the program with a period, then this condition never occurs.</p>
<p>One subtlety is that reactions triggered by <span class="lf_keywords">shutdown</span> will be invoked one microstep later than the last tag at which there was an event. They cannot be invoked at the same tag because it is only after that last tag has completed that the runtime system can be sure that there are no future events. It would not be correct to trigger the <span class="lf_keywords">shutdown</span> reactions at that point because it would be impossible to respect the required reaction ordering.</p>
<div class="lf-c lf-py lf-ts">
<p>Starvation termination is not currently implemented for federated execution. You will need to use one of the other mechanisms to terminate a federated program.</p>
</div>
<h2>Stop Request</h2>
<p>If a reaction calls the built-in <code>request_stop()</code> function, then it is requesting that the program cease execution as soon as possible. This cessation will normally occur in the next microstep. The current tag will be completed as normal. Then the tag will be advanced by one microstep, and reactions triggered by <span class="lf_keywords">shutdown</span> will be executed, along with any other reactions with triggers at that tag, with all reactions executed in precedence order.</p>
<div class="lf-c lf-py lf-ts">
<p>In a federated execution, things are more complicated. In general, it is not possible to cease execution in the next microstep because this would mean that every federate has a communication channel to every other with delay equal to one microstep. This this does not create a causality loop, but it means that all federates have to advance time in lockstep, which creates a global barrier synchronization that would likely kill performance. It will also make decentralized coordination impossible because the safe-to-process (STP) threshold for all federates will diverge to infinity.</p>
<p>For <strong>centralized coordination</strong>, when a reaction in a federate calls <code>request_stop()</code>, the federate sends a <strong>STOP_REQUEST</strong> message to the RTI with its current timestamp <em>t</em> as a payload and completes execution of any other reactions triggered at the current tag. It then blocks, waiting for a <strong>STOP_GRANTED</strong> message with a timestamp payload <em>s</em>. If <em>s</em> > <em>t</em>, then it sets <code>timeout</code> = <em>s</em> and continues executing, using the timeout mechanism (see above) to stop. If <em>s</em> = <em>t</em>, then schedules the shutdown phase to occur one microstep later, as in the unfederated case.</p>
<p>When the RTI receives a <strong>STOP_REQUEST</strong> message from a federate, it forwards it to all other federates and waits for a reply from all. Each reply will have a timestamp payload. The RTI chooses <em>s</em>, the largest of these timestamps, and sends a <strong>STOP_GRANTED</strong> message to all federates with payload <em>s</em>.</p>
<p>When a federate receives a <strong>STOP_REQUEST</strong> message, it replies with its current logical time <em>t</em>, completes its current tag (if one is progress), and blocks, waiting for a <strong>STOP_GRANTED</strong> message from the RTI. When it gets the reply with payload <em>s</em>, if <em>s</em> > <em>t</em>, then it sets <code>timeout</code> = <em>s</em> and continues executing, using the timeout mechanism (see above) to stop. If <em>s</em> = <em>t</em>, then it schedules the shutdown phase to occur one microstep later, as in the unfederated case.</p>
</div>
<h2>External Signal</h2>
<p>A control-C or other kill signal to a running Lingua Franca program will cause execution to stop immediately.</p>
<div class="lf-c lf-py lf-ts">
<p>For federated programs, each federate and the RTI catches external signals to shut down in an orderly way.</p>
<p>When a federate gets such an external signal (e.g. control-C), it sends a <strong>RESIGN</strong> message to the RTI and an <strong>EOF</strong> (end of file) on each socket connection to another federate. It then closes all sockets and shut down. The RTI and all other federates should continue running until some other termination condition occurs.</p>
<p>When the RTI gets such an external signal (e.g. control-C), it broadcasts a <strong>STOP_REQUEST</strong> message to all federates, wait for their replies (with a timeout in case the federate or the network has failed), choose the maximum timestamp <em>s</em> on the replies, broadcast a <strong>STOP_GRANTED</strong> message to all federates with payload <em>s</em>, and wait for <strong>LOGICAL_TIME_COMPLETE</strong> messages as above.</p>
</div></div></div></article>